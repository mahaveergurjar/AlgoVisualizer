/**
 * Centralized catalog for problems across the site.
 * This file is the single source of truth for all algorithm and problem data.
 */

// --- ✅ Combined Icon Imports for ALL Categories ---
import {
  AlignLeft,
  ArrowLeftRight,
  ArrowRightLeft,
  ArrowUpDown,
  BarChart3,
  BarChart4,
  Calculator,
  Check,
  CheckCircle,
  CheckCircle2,
  Circle,
  Clock,
  Code2,
  Coins,
  Container,
  Crown,
  Database,
  Droplets,
  Edit,
  Filter,
  GitBranch,
  GitMerge,
  Grid,
  Hash,
  Infinity as InfinityIcon,
  Layers,
  LineChart,
  List,
  ListOrdered,
  MapPin,
  Maximize2,
  Merge,
  Minus,
  Mountain,
  MoveRight,
  Plus,
  RefreshCw,
  Repeat,
  RotateCcw,
  Scissors,
  Search,
  SearchCode,
  Settings,
  Share2,
  ShoppingBasket,
  Shuffle,
  Target,
  Text,
  ToggleRight,
  Trees,
  TrendingUp,
  Users,
  Grid3x3,
  Zap,
  PackageOpen
} from "lucide-react";

export const problems = [
  // =================================================================
  // ARRAYS
  // =================================================================
  {
    label: "Container With Most Water",
    category: "Arrays",
    subpage: "ContainerWithMostWater",
    keywords: ["array", "two pointers", "container", "water", "11"],
    number: "11",
    icon: Container,
    description: "Find two lines that form a container with the most water.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #11", "GfG"],
    tags: ["Two Pointers", "Area"],
  },
  {
    label: "3Sum",
    category: "Arrays",
    subpage: "ThreeSum",
    keywords: ["array", "two pointers", "three sum", "3sum", "triplet", "15"],
    number: "15",
    icon: Target,
    description: "Find all unique triplets that sum up to zero.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-emerald-500 to-green-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n²)",
    platforms: ["LeetCode #15", "GfG"],
    tags: ["Two Pointers", "Sorting", "Triplets"],
  },
  {
    label: "4Sum",
    category: "Arrays",
    subpage: "4Sum",
    keywords: [
      "array",
      "four sum",
      "4sum",
      "quadruplets",
      "two pointers",
      "18",
    ],
    number: "18",
    icon: Layers,
    description:
      "Find all unique quadruplets in the array which give the sum of a target.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n³)",
    platforms: ["LeetCode #18", "GfG"],
    tags: ["Two Pointers", "Sorting", "Quadruplets"],
  },
  {
    label: "Trapping Rain Water",
    category: "Arrays",
    subpage: "TrappingRainWater",
    keywords: ["array", "two pointers", "rain", "water", "42"],
    number: "42",
    icon: Droplets,
    description: "Compute how much water can be trapped after raining.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-rose-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #42", "GfG"],
    tags: ["Two Pointers", "DP", "Water"],
  },
  {
    label: "Maximum Subarray",
    category: "Arrays",
    subpage: "MaximumSubarray",
    keywords: [
      "array",
      "kadane",
      "maximum subarray",
      "53",
      "subarray sum",
      "dynamic programming",
    ],
    number: "53",
    icon: TrendingUp,
    description: "Find the subarray with the largest sum.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Kadane's Algorithm",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #53", "GfG"],
    tags: ["DP", "Kadane", "Classic"],
  },
  {
    label: "Merge Intervals",
    category: "Arrays",
    subpage: "MergeIntervals",
    keywords: ["array", "intervals", "merge", "56", "overlapping", "sorting"],
    number: "56",
    icon: Merge,
    description: "Merge all overlapping intervals.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-red-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Sorting + Greedy",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #56", "GfG"],
    tags: ["Intervals", "Sorting", "Important"],
  },
  {
    label: "Best Time to Buy and Sell Stock",
    category: "Arrays",
    subpage: "BestTimeToBuyAndSellStock",
    keywords: ["array", "stock", "profit", "buy", "sell", "121"],
    number: "121",
    icon: TrendingUp,
    description: "Find the maximum profit from a single buy and sell.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-green-500 to-emerald-600",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "One Pass",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #121"],
    tags: ["Kadane's variant", "Profit"],
  },
  {
    label: "Maximum Gap",
    category: "Arrays",
    subpage: "MaximumGap",
    keywords: ["array", "maximum", "gap", "sorting", "bucket sort", "164"],
    number: "164",
    icon: MoveRight,
    description: "Find the max gap between successive elements in sorted form.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Sorting, Traversal",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #164"],
    tags: ["Sorting", "Traversal"],
  },
  {
    label: "Rotate Array",
    category: "Arrays",
    subpage: "RotateArray",
    keywords: ["array", "rotate", "reverse", "in-place", "189"],
    number: "189",
    icon: RotateCcw,
    description: "Rotate the array to the right by k steps.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Reverse Algorithm",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #189", "GfG"],
    tags: ["Array", "In-place", "Rotation"],
  },
  {
    label: "Product of Array Except Self",
    category: "Arrays",
    subpage: "ProductOfArrayExceptSelf",
    keywords: [
      "array",
      "product",
      "prefix",
      "suffix",
      "238",
      "except self",
      "division",
    ],
    number: "238",
    icon: Calculator,
    description: "Find the product of all elements except self.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-indigo-500 to-purple-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Prefix & Suffix Products",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #238", "GfG"],
    tags: ["Array", "Prefix Sum", "Important"],
  },
  {
    label: "Move Zeros",
    category: "Arrays",
    subpage: "MoveZeros",
    keywords: ["array", "move", "zeros", "two pointers", "in-place", "283"],
    number: "283",
    icon: MoveRight,
    description: "Move all zeros to the end while maintaining order.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-violet-500 to-purple-500",
    iconColor: "text-violet-400",
    iconBg: "bg-violet-500/20",
    borderColor: "border-violet-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #283", "GfG"],
    tags: ["Two Pointers", "Partitioning"],
  },
  {
    label: "Split Array Largest Sum",
    category: "Arrays",
    subpage: "SplitArrayLargestSum",
    keywords: [
      "array",
      "split",
      "largest sum",
      "binary search",
      "greedy",
      "410",
    ],
    number: "410",
    icon: BarChart3,
    description: "Split array so the largest subarray sum is minimized.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-pink-500 to-rose-600",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Binary Search + Greedy",
    timeComplexity: "O(n log(sum))",
    platforms: ["LeetCode #410"],
    tags: ["Binary Search", "Greedy"],
  },
  {
    label: "Squares of a Sorted Array",
    category: "Arrays",
    subpage: "SquaresOfSortedArray",
    keywords: ["array", "squares", "sorted", "two pointers", "977"],
    number: "977",
    icon: ArrowUpDown,
    description: "Square each number and return the sorted array.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #977"],
    tags: ["Two Pointers", "Sorting"],
  },
  {
    label: "Max Consecutive Ones III",
    category: "Arrays",
    subpage: "MaxConsecutiveOnesIII",
    keywords: ["array", "sliding window", "ones", "1004"],
    number: "1004",
    icon: ToggleRight,
    description: "Longest subarray of 1s after flipping at most K zeros.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #1004", "GfG"],
    tags: ["Sliding Window", "Ones"],
  },
  {
    label: "Sum of Subarray Ranges",
    category: "Arrays",
    subpage: "SubarrayRanges",
    keywords: ["array", "ranges", "subarray", "stack", "monotonic", "2104"],
    number: "2104",
    icon: ArrowUpDown,
    description: "Sum of differences between max and min in all subarrays.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Array / Monotonic Stack",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #2104", "GfG"],
    tags: ["Subarrays", "Stack"],
  },
  {
    label: "Find Maximum Element",
    category: "Arrays",
    subpage: "FindMaxElement",
    keywords: ["array", "max", "find", "largest", "basic"],
    number: "1",
    icon: Maximize2,
    description: "Find the largest element in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Traversal"],
  },
  {
    label: "Find Minimum Element",
    category: "Arrays",
    subpage: "FindMinElement",
    keywords: ["array", "min", "find", "smallest", "basic"],
    number: "2",
    icon: Minus,
    description: "Find the smallest element in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-emerald-500 to-teal-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Traversal"],
  },
  {
    label: "Array Sum",
    category: "Arrays",
    subpage: "ArraySum",
    keywords: ["array", "sum", "total", "basic"],
    number: "3",
    icon: Plus,
    description: "Calculate the sum of all elements in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Sum"],
  },
  {
    label: "Reverse Array",
    category: "Arrays",
    subpage: "ReverseArray",
    keywords: ["array", "reverse", "two pointers", "in-place", "basic"],
    number: "4",
    icon: RefreshCw,
    description: "Reverse the elements of an array in place.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Two Pointers"],
  },
  {
    label: "Two Sum",
    category: "Arrays",
    subpage: "TwoSum",
    keywords: ["array", "two sum", "target", "hashmap", "1"],
    number: "1",
    icon: Target,
    description: "Find two numbers that add up to the target value.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #1", "GfG"],
    tags: ["Hashing", "Pairs"],
  },
  {
    label: "Count Zeros in Array",
    category: "Arrays",
    subpage: "CountZeros",
    keywords: ["array", "count", "zeros", "basic"],
    number: "3",
    icon: Hash,
    description: "Count the number of zero elements in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["GfG"],
    tags: ["Beginner", "Counting"],
  },

  // =================================================================
  // SLIDING WINDOWS
  // =================================================================
  {
    label: "Sliding Window Maximum",
    category: "SlidingWindows",
    subpage: "SlidingWindowMaximum",
    keywords: ["sliding window", "maximum", "deque", "monotonic", "239"],
    number: "239",
    icon: BarChart3,
    description: "Find the maximum value in each sliding window of size k.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Deque / Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Deque", "Hard"],
  },
  {
    label: "Max Consecutive Ones III", // Duplicate but kept for category context
    category: "SlidingWindows",
    subpage: "MaxConsecutiveOnesIII",
    keywords: [
      "sliding window",
      "max",
      "consecutive",
      "ones",
      "flip",
      "1004",
      "array",
    ],
    number: "1004",
    icon: ToggleRight,
    description:
      "Find the longest subarray of 1s after flipping at most K zeros.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Two Pointers", "Variable Window"],
  },
  {
    label: "Fruit Into Baskets",
    category: "SlidingWindows",
    subpage: "FruitIntoBaskets",
    keywords: ["sliding window", "fruit", "baskets", "distinct", "904"],
    number: "904",
    icon: ShoppingBasket,
    description:
      "Find the length of the longest subarray with at most two distinct fruit types.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Variable Window", "Hash Map"],
  },
  {
    label: "Minimum Window Substring",
    category: "SlidingWindows",
    subpage: "MinimumWindow",
    keywords: [
      "sliding window",
      "minimum",
      "window",
      "substring",
      "string",
      "hash map",
      "76",
    ],
    number: "76",
    icon: Target,
    description:
      "Find the minimum window in string s that contains all characters of string t.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n+m)",
    platforms: ["LeetCode #76", "GfG"],
    tags: ["String", "Hash Map", "Minimum Window", "Advanced"],
  },
  {
    label: "Longest Substring Without Repeating Characters",
    category: "SlidingWindows",
    subpage: "LongestSubstring",
    keywords: [
      "sliding window",
      "longest",
      "substring",
      "repeating",
      "unique",
      "string",
      "hash map",
      "3",
    ],
    number: "3",
    icon: Hash,
    description:
      "Find the length of the longest substring without repeating characters.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #3", "GfG"],
    tags: ["String", "Hash Map", "Unique Characters"],
  },

  // =================================================================
  // BINARY SEARCH (New Category Added and Sorted by Number)
  // =================================================================
  {
    label: "Basic Binary Search",
    category: "BinarySearch",
    subpage: "BinarySearchBasic",
    keywords: ["binary search", "basic", "search", "sorted"],
    number: "N/A",
    icon: SearchCode,
    description:
      "The fundamental logarithmic search algorithm on a sorted array.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(log n)",
    platforms: ["All Platforms"],
    tags: ["Fundamental", "Logarithmic"],
  },
  {
    label: "Search a 2D Matrix",
    category: "BinarySearch",
    subpage: "Search2DMatrix",
    keywords: ["binary search", "matrix", "2d", "74"],
    number: "74",
    icon: SearchCode,
    description:
      "Search for a value in an m x n matrix where rows and columns are sorted.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-fuchsia-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Binary Search on 2D Array",
    timeComplexity: "O(log(m*n))",
    platforms: ["LeetCode #74"],
    tags: ["Matrix", "Logarithmic"],
  },
  {
    label: "Find First and Last Position of Element in Sorted Array",
    category: "BinarySearch",
    subpage: "FindFirstAndLastPosition",
    keywords: ["binary search", "first", "last", "position", "34"],
    number: "34",
    icon: SearchCode,
    description:
      "Find the starting and ending position of a given target value.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Modified Binary Search",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #34"],
    tags: ["Boundary Search", "Logarithmic"],
  },
  {
    label: "Search in Rotated Sorted Array",
    category: "BinarySearch",
    subpage: "SearchInRotatedSortedArray",
    keywords: ["binary search", "rotated", "sorted array", "33"],
    number: "33",
    icon: SearchCode,
    description: "Search for a target value in a rotated sorted array.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-red-500 to-rose-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Binary Search (Pivot)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #33"],
    tags: ["Pivot", "Logarithmic", "Rotated Array"],
  },
  {
    label: "Find Peak Element",
    category: "BinarySearch",
    subpage: "FindPeakElement",
    keywords: ["binary search", "peak", "element", "162"],
    number: "162",
    icon: Mountain,
    description:
      "Find a peak element in an array (an element greater than its neighbors).",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Binary Search (Gradient)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #162"],
    tags: ["Gradient", "Logarithmic"],
  },
  {
    label: "Find Minimum in Rotated Sorted Array",
    category: "BinarySearch",
    subpage: "FindMinimumInRotatedSortedArray",
    keywords: ["binary search", "minimum", "rotated", "sorted array", "153"],
    number: "153",
    icon: RotateCcw,
    description: "Find the minimum element in a rotated sorted array.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-indigo-500 to-blue-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Binary Search (Pivot)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #153"],
    tags: ["Pivot", "Logarithmic", "Rotated Array"],
  },
  {
    label: "Peak Index in a Mountain Array",
    category: "BinarySearch",
    subpage: "PeakIndexInMountainArray",
    keywords: ["binary search", "mountain", "peak", "852"],
    number: "852",
    icon: Mountain,
    description: "Find the index of the peak element in a mountain array.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Binary Search",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #852"],
    tags: ["Mountain Array", "Logarithmic"],
  },
  {
    label: "Min Speed to Arrive on Time",
    category: "BinarySearch",
    subpage: "MinSpeedToArriveOnTime",
    keywords: ["binary search", "speed", "time", "optimization", "1870"],
    number: "1870",
    icon: Clock,
    description: "Find the minimum speed to arrive at the destination on time.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Binary Search on Answer",
    timeComplexity: "O(n log(max_speed))",
    platforms: ["LeetCode #1870"],
    tags: ["Search on Answer", "Optimization"],
  },
  {
    label: "Median of Two Sorted Arrays",
    category: "BinarySearch",
    subpage: "MedianOfTwoSortedArrays",
    keywords: ["binary search", "median", "sorted array", "hard", "4"],
    number: "4",
    icon: Share2,
    description: "Find the median of two sorted arrays of different sizes.",
    difficulty: "Hard",
    tier: "Tier 4",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-fuchsia-500 to-purple-500",
    iconColor: "text-fuchsia-400",
    iconBg: "bg-fuchsia-500/20",
    borderColor: "border-fuchsia-500/30",
    technique: "Binary Search on Partition",
    timeComplexity: "O(log(min(m,n)))",
    platforms: ["LeetCode #4"],
    tags: ["Partition", "Hard", "Classic"],
  },

  // =================================================================
  // LINKED LIST
  // =================================================================
  {
    label: "Linked List Cycle",
    category: "LinkedList",
    subpage: "LinkedListCycle",
    keywords: [
      "linked list",
      "cycle",
      "loop",
      "floyd",
      "tortoise",
      "hare",
      "141",
    ],
    number: "141",
    icon: InfinityIcon,
    description: "Determine if a given linked list contains a cycle or a loop.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-emerald-500 to-teal-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Floyd's Cycle",
    timeComplexity: "O(n)",
    tags: ["Two Pointers", "Classic"],
  },
  {
    label: "Reverse Linked List",
    category: "LinkedList",
    subpage: "ReverseLinkedList",
    keywords: ["linked list", "reverse", "iterative", "recursive", "206"],
    number: "206",
    icon: RefreshCw,
    description: "Reverse a singly linked list and return the reversed list.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-lime-500",
    iconColor: "text-lime-400",
    iconBg: "bg-lime-500/20",
    borderColor: "border-lime-500/30",
    technique: "Iterative & Recursive Reversal",
    timeComplexity: "O(n)",
    tags: ["Pointers", "Fundamental"],
  },
  {
    label: "Merge Two Sorted Lists",
    category: "LinkedList",
    subpage: "MergeTwoSortedLists",
    keywords: [
      "linked list",
      "merge",
      "sorted",
      "two pointers",
      "dummy node",
      "21",
    ],
    number: "21",
    icon: GitMerge,
    description:
      "Merge two sorted linked lists and return as a single sorted list.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-purple-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Two Pointers & Dummy Node",
    timeComplexity: "O(m + n)",
    tags: ["Two Pointers", "Classic"],
  },
  {
    label: "Sort List",
    category: "LinkedList",
    subpage: "SortList",
    keywords: [
      "linked list",
      "merge sort",
      "sort",
      "divide and conquer",
      "148",
    ],
    number: "148",
    icon: ListOrdered,
    description: "Sort a linked list in ascending order using merge sort.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-yellow-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Merge Sort (Divide & Conquer)",
    timeComplexity: "O(n log n)",
    tags: ["Merge Sort", "Linked List", "Divide and Conquer"],
  },
  {
    label: "Swap Pairs",
    category: "LinkedList",
    subpage: "SwapPairs",
    keywords: ["linked list", "swap pairs", "recursion", "iteration", "24"],
    number: "24",
    icon: ArrowLeftRight,
    description: "Swap every two adjacent nodes in a linked list.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Pointer Manipulation (Recursion / Iteration)",
    timeComplexity: "O(n)",
    tags: ["Linked List", "Recursion", "Swapping"],
  },

  // =================================================================
  // STACK
  // =================================================================
  {
    label: "Stack Operations",
    category: "Stack",
    subpage: "StackOperations",
    keywords: ["stack", "operations", "push", "pop", "peek", "LIFO", "basic"],
    number: "Basic",
    icon: Layers,
    description: "Visualize the core stack operations: Push, Pop, and Peek.",
    difficulty: "Fundamental",
    tier: "Tier 1",
    difficultyColor: "text-cyan-400",
    difficultyBg: "bg-cyan-400/10",
    difficultyBorder: "border-cyan-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "LIFO",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "LIFO"],
  },
  {
    label: "Permutation",
    category: "Stack",
    subpage: "Permutation",
    keywords: ["stack", "permutation", "iterative", "backtracking", "46"],
    number: "46",
    icon: ArrowUpDown,
    description:
      "Generate all permutations of an array iteratively using an explicit stack.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-emerald-500 to-green-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Explicit Stack",
    timeComplexity: "O(n × n!)",
    tags: ["Backtracking", "Iterative"],
  },
  {
    label: "Largest Rectangle in Histogram",
    category: "Stack",
    subpage: "LargestRectangleHistogram",
    keywords: ["stack", "largest", "rectangle", "histogram", "monotonic", "84"],
    number: "84",
    icon: BarChart4,
    description: "Given bar heights, find the area of the largest rectangle.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-rose-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Hard"],
  },
  {
    label: "Remove K Digits",
    category: "Stack",
    subpage: "RemoveKDigits",
    keywords: ["stack", "remove", "k digits", "smallest", "greedy", "402"],
    number: "402",
    icon: Scissors,
    description:
      "Given a number, remove K digits to create the smallest possible new number.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Greedy + Stack",
    timeComplexity: "O(n)",
    tags: ["Greedy", "Monotonic"],
  },
  {
    label: "Sum of Subarray Ranges", // Also in Arrays
    category: "Stack",
    subpage: "SubarrayRanges",
    keywords: [
      "stack",
      "subarray",
      "ranges",
      "sum",
      "monotonic",
      "2104",
      "array",
    ],
    number: "2104",
    icon: ArrowUpDown,
    description: "Calculate sum of (max - min) over all subarrays.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-violet-500 to-purple-500",
    iconColor: "text-violet-400",
    iconBg: "bg-violet-500/20",
    borderColor: "border-violet-500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Arrays"],
  },
  {
    label: "Next Greater Element",
    category: "Stack",
    subpage: "NextGreaterElement",
    keywords: [
      "stack",
      "next",
      "greater",
      "element",
      "monotonic",
      "circular",
      "496",
    ],
    number: "496",
    icon: ArrowUpDown,
    description:
      "Find the next greater element for each element in a circular array.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-fuchsia-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Circular Array"],
  },

  // =================================================================
  // QUEUE
  // =================================================================
  {
    label: "Basic Queue (FIFO)",
    category: "Queue",
    subpage: "BasicQueue",
    keywords: [
      "queue",
      "fifo",
      "first-in-first-out",
      "enqueue",
      "dequeue",
      "linear",
    ],
    number: "N/A",
    icon: ArrowRightLeft,
    description:
      "Elements are added at the rear and removed from the front, like a waiting line.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-rose-500 to-pink-600",
    iconColor: "text-rose-400",
    iconBg: "bg-rose-500/20",
    borderColor: "border-rose-500/30",
    technique: "Linear Structure",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "FIFO"],
  },
  {
    label: "Circular Queue",
    category: "Queue",
    subpage: "CircularQueue",
    keywords: ["queue", "circular", "ring buffer", "array optimization"],
    number: "N/A",
    icon: List,
    description: "Optimized queue using a circular array to reuse space.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-pink-500 to-rose-600",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Circular Array",
    timeComplexity: "O(1)",
    tags: ["Optimization", "Array"],
  },
  {
    label: "Implement Queue using Stacks",
    category: "Queue",
    subpage: "QueueUsingStacks",
    keywords: ["queue", "implement", "stacks", "design", "amortized", "232"],
    number: "232",
    icon: Container,
    description: "Implement a FIFO queue using only two LIFO stacks.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-indigo-600",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Two Stacks",
    timeComplexity: "Amortized O(1)",
    tags: ["Design", "Stack"],
  },

  // =================================================================
  // SORTING
  // =================================================================
  {
    label: "Bubble Sort",
    category: "Sorting",
    subpage: "BubbleSort",
    keywords: ["sorting", "bubble", "swap", "basic"],
    number: "912",
    icon: ArrowUpDown,
    description:
      "A simple algorithm that repeatedly steps through the list, comparing and swapping adjacent elements.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Swapping",
    timeComplexity: "O(n²)",
    tags: ["Basic", "In-place"],
  },
  {
    category: "Sorting",
    subpage: "BucketSort",
    label: "Bucket Sort",
    keywords: ["sorting","bucket","linear-time","range-based","concatenate"],
    number: "N/A",
    icon: PackageOpen,
    description:
      "Distribution-based, non-comparative sorting: normalize values into buckets, sort each bucket (e.g., with a stable insertion sort), and concatenate.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-teal-300",
    difficultyBg: "bg-teal-400/10",
    difficultyBorder: "border-teal-400/30",
    gradient: "from-teal-600 to-cyan-600",
    iconColor: "text-teal-300",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Distribution",
    timeComplexity: "O(n + k)",
    tags: ["Stable (with insertion)","Not in-place","Range-dependent","Avg linear"],
  },
  {
    label: "Merge Sort",
    category: "Sorting",
    subpage: "MergeSort",
    keywords: ["sorting", "merge", "divide and conquer", "stable"],
    number: "N/A",
    icon: GitMerge,
    description:
      "An efficient, stable algorithm using the divide and conquer paradigm.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-500 to-amber-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "Stable"],
  },
  {
    label: "Quick Sort",
    category: "Sorting",
    subpage: "QuickSort",
    keywords: ["sorting", "quick", "partition", "pivot"],
    number: "N/A",
    icon: Shuffle,
    description:
      "An efficient algorithm that uses partitioning to divide the array into smaller sub-arrays.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-red-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Partitioning",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "In-place"],
  },
  {
    label: "Insertion Sort",
    category: "Sorting",
    subpage: "InsertionSort",
    keywords: ["sorting", "insertion", "insert", "stable"],
    number: "N/A",
    icon: Code2,
    description:
      "A simple algorithm that builds the final sorted array one element at a time.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-lime-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Insertion",
    timeComplexity: "O(n²)",
    tags: ["Basic", "Stable"],
  },
  {
    label: "Radix Sort",
    category: "Sorting",
    subpage: "RadixSort",
    keywords: ["sorting", "radix", "digit", "non-comparative"],
    number: "N/A",
    icon: Layers,
    description:
      "A non-comparative algorithm that sorts numbers by processing individual digits.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Digit-wise Sorting",
    timeComplexity: "O(d*(n+k))",
    tags: ["Non-comparative", "Linear Time"],
  },
  {
    label: "Counting Sort",
    category: "Sorting",
    subpage: "CountingSort",
    keywords: ["sorting", "counting", "frequency", "non-comparative"],
    number: "N/A",
    icon: BarChart3,
    description:
      "A non-comparative algorithm that counts the frequency of each element to sort them.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-yellow-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Counting & Placement",
    timeComplexity: "O(n+k)",
    tags: ["Non-comparative", "Linear Time"],
  },
  {
    label: "Heap Sort",
    category: "Sorting",
    subpage: "HeapSort",
    keywords: ["sorting", "heap", "priority queue", "binary heap"],
    number: "N/A",
    icon: Trees,
    description:
      "A comparison-based technique based on a binary heap data structure.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Heap-based Sorting",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "In-place"],
  },
  {
    label: "Selection Sort",
    category: "Sorting",
    subpage: "SelectionSort",
    keywords: ["sorting", "selection", "select", "minimum"],
    number: "N/A",
    icon: Target,
    description:
      "A simple algorithm that repeatedly selects the minimum element and moves it to the sorted part.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Selection",
    timeComplexity: "O(n²)",
    tags: ["Basic", "In-place"],
  },
  {
    label: "Shell Sort",
    category: "Sorting",
    subpage: "ShellSort",
    keywords: ["sorting", "shell", "gap", "insertion sort"],
    number: "N/A",
    icon: Layers,
    description:
      "An optimized version of insertion sort that allows the exchange of items that are far apart.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Gap Insertion",
    timeComplexity: "O(n^1.5)",
    tags: ["Optimization", "In-place"],
  },
  {
    label: "Comb Sort",
    category: "Sorting",
    subpage: "CombSort",
    keywords: ["sorting", "comb", "gap", "bubble sort"],
    number: "N/A",
    icon: Filter,
    description:
      "An improvement over Bubble Sort, Comb Sort eliminates 'turtles' for better performance.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Gap Insertion",
    timeComplexity: "O(n log n)",
    tags: ["Optimization", "In-place"],
  }, // HEAPS // =================================================================
  // =================================================================
  {
    category: "Heaps",
    subpage: "Heapify", // <-- This MUST match the 'case' in HeapsPage
    label: "Heapify (Build Heap)",
    number: "H-01", // Custom ID for a concept
    difficulty: "Medium",
    difficultyBg: "bg-yellow-500/10",
    difficultyColor: "text-yellow-400",
    difficultyBorder: "border-yellow-500/30",
    tier: "Tier 1",
    description:
      "Learn how to convert an unordered array into a max-heap in-place using the sift-down (heapify) operation.",
    icon: Layers, // This is already imported
    gradient: "from-teal-700 to-cyan-800",
    borderColor: "border-teal-600",
    iconBg: "bg-teal-700/20",
    iconColor: "text-teal-300",
    tags: ["Heap", "In-Place", "Data Structure", "Concept"],
    technique: "Sift-Down",
    timeComplexity: "O(n)",
    platforms: ["Concept"],
  },
  {
    category: "Heaps",
    subpage: "TopKFrequent", // <-- This MUST match the 'case' in HeapsPage
    label: "Top K Frequent Elements",
    number: "347",
    difficulty: "Medium",
    difficultyBg: "bg-yellow-500/10",
    difficultyColor: "text-yellow-400",
    difficultyBorder: "border-yellow-500/30",
    tier: "Tier 2",
    description:
      "Given an integer array and an integer k, return the k most frequent elements. A min-heap is a perfect solution.",
    icon: TrendingUp, // This is already imported
    gradient: "from-purple-700 to-indigo-800",
    borderColor: "border-purple-600",
    iconBg: "bg-purple-700/20",
    iconColor: "text-purple-300",
    tags: ["Heap", "Priority Queue", "Hash Map"],
    technique: "Min-Heap",
    timeComplexity: "O(n log k)",
    platforms: ["LeetCode #347"],
  },
  {
    category: "Heaps",
    subpage: "TaskScheduler", // <-- Este será o nome do nosso novo arquivo/componente
    label: "Task Scheduler",
    number: "621",
    difficulty: "Medium",
    difficultyBg: "bg-yellow-500/10",
    difficultyColor: "text-yellow-400",
    difficultyBorder: "border-yellow-500/30",
    tier: "Tier 2",
    description:
      'Determine o número mínimo de intervalos para completar todas as tarefas com um "cooldown" (folga).',
    icon: Clock, // Ícone perfeito para agendamento
    gradient: "from-blue-700 to-sky-800", // Um novo gradiente
    borderColor: "border-blue-600",
    iconBg: "bg-blue-700/20",
    iconColor: "text-blue-300",
    tags: ["Heap", "Greedy", "Priority Queue", "Scheduling"],
    technique: "Max-Heap / Greedy",
    timeComplexity: "O(N)", // O(N) para contar, o resto é O(1) pois o alfabeto é fixo (26)
    platforms: ["LeetCode #621"],
    keywords: [
      "heap",
      "task",
      "scheduler",
      "cooldown",
      "greedy",
      "priority queue",
      "621",
    ],
  },

  // =================================================================
  // TREES
  // =================================================================
  {
    label: "Construct Tree from Traversal",
    category: "Trees",
    subpage: "ConstructBinaryTree",
    keywords: [
      "tree",
      "construct",
      "build",
      "preorder",
      "inorder",
      "traversal",
      "105",
    ],
    number: "105",
    icon: GitMerge,
    description:
      "Build a binary tree from its preorder and inorder traversal arrays.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-emerald-500 to-green-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Recursion & Hashing",
    timeComplexity: "O(n)",
    tags: ["Recursion", "Hash Map"],
  },
  {
    label: "LCA of Deepest Leaves",
    category: "Trees",
    subpage: "LCAofDeepestLeaves",
    keywords: [
      "tree",
      "lca",
      "lowest common ancestor",
      "deepest leaves",
      "dfs",
      "1123",
    ],
    number: "1123",
    icon: GitMerge,
    description:
      "Find the lowest common ancestor node of a binary tree's deepest leaves.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Depth-First Search (DFS)",
    timeComplexity: "O(n)",
    tags: ["DFS", "Recursion"],
  },
  {
    label: "Validate Binary Search Tree",
    category: "Trees",
    subpage: "ValidateBST",
    keywords: ["tree", "validate", "bst", "binary search tree", "dfs", "98"],
    number: "98",
    icon: CheckCircle,
    description:
      "Determine if a given binary tree is a valid Binary Search Tree (BST).",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "DFS & Boundaries",
    timeComplexity: "O(n)",
    tags: ["DFS", "Validation"],
  },
  {
    label: "AVL Tree Visualizer",
    category: "Trees",
    subpage: "AVLTree",
    keywords: [
      "tree",
      "avl",
      "balanced",
      "binary search tree",
      "rotations",
      "110",
    ],
    number: "110",
    icon: GitMerge,
    description: "Visualize AVL tree insertions and self-balancing rotations.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Balanced Binary Search Tree",
    timeComplexity: "O(log n)",
    tags: ["Self-Balancing", "BST"],
  },
  {
    label: "Symmetric Tree",
    category: "Trees",
    subpage: "SymmetricTreeVisualizer",
    keywords: [
      "tree",
      "symmetric",
      "mirror",
      "binary tree",
      "recursion",
      "iterative",
      "101",
    ],
    number: "111",
    icon: GitBranch,
    description:
      "Check whether a binary tree is symmetric (a mirror of itself) using recursion or iterative BFS/DFS approaches.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-400 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Tree Traversal (Recursion / BFS)",
    timeComplexity: "O(n)",
    tags: ["Recursion", "Mirror", "BFS", "DFS"],
  },

  // =================================================================
  // DESIGN
  // =================================================================
  {
    label: "LRU Cache",
    category: "Design",
    subpage: "LRUCache",
    keywords: [
      "design",
      "lru",
      "cache",
      "least recently used",
      "hashmap",
      "doubly linked list",
      "146",
    ],
    number: "146",
    icon: Settings,
    description:
      "Implement an LRU (Least Recently Used) cache with O(1) get and put operations.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-500 to-emerald-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "HashMap + Doubly Linked List",
    timeComplexity: "O(1)",
    tags: ["Cache", "Classic"],
  },
  {
    label: "LFU Cache",
    category: "Design",
    subpage: "LFUCache",
    keywords: [
      "design",
      "lfu",
      "cache",
      "least frequently used",
      "hashmap",
      "460",
    ],
    number: "460",
    icon: Settings,
    description:
      "Implement an LFU (Least Frequently Used) cache that evicts the least frequently used key.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-pink-500 to-rose-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "HashMap + Frequency Map",
    timeComplexity: "O(1)",
    tags: ["Cache", "Hard"],
  },
  {
    label: "Design HashMap",
    category: "Design",
    subpage: "DesignHashMap",
    keywords: ["design", "hashmap", "hashtable", "hash function", "706"],
    number: "706",
    icon: Settings,
    description:
      "Design a HashMap that supports put, get, and remove operations in O(1) time.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-lime-500",
    iconColor: "text-lime-400",
    iconBg: "bg-lime-500/20",
    borderColor: "border-lime-500/30",
    technique: "Array + Hashing",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "Data Structure"],
  },
  {
    label: "Design Linked List",
    category: "Design",
    subpage: "DesignLinkedList",
    keywords: ["design", "linked list", "pointers", "707"],
    number: "707",
    icon: Settings,
    description:
      "Design a Linked List that supports insert, delete, and get operations.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-500 to-amber-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Pointers",
    timeComplexity: "O(n)",
    tags: ["Fundamental", "Data Structure"],
  },
  {
    label: "Min Stack",
    category: "Design",
    subpage: "MinStack",
    keywords: ["design", "min stack", "stack", "minimum", "155"],
    number: "155",
    icon: Layers,
    description:
      "Design a stack that supports retrieving the minimum element in constant time.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Stack + Min Tracking",
    timeComplexity: "O(1)",
    tags: ["Stack", "Optimization"],
  },
  {
    label: "Implement Trie (Prefix Tree)",
    category: "Design",
    subpage: "ImplementTrie",
    keywords: ["design", "trie", "prefix tree", "strings", "208"],
    number: "208",
    icon: Search,
    description:
      "Implement a trie with insert, search, and startsWith methods.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Trie / Tree",
    timeComplexity: "O(m)",
    tags: ["Tree", "Strings"],
  },

  // =================================================================
  // PATHFINDING
  // =================================================================
  {
    label: "A* Pathfinding",
    category: "Pathfinding",
    subpage: "AStar",
    keywords: [
      "pathfinding",
      "a star",
      "a*",
      "heuristic",
      "optimal path",
      "astar",
      "shortest path",
      "grid search",
    ],
    number: "N/A",
    icon: Target,
    description:
      "Optimal pathfinding algorithm using heuristic functions. Guarantees shortest path with efficient exploration.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-pink-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Heuristic Search",
    timeComplexity: "O(b^d)",
    platforms: ["All Platforms"],
    tags: ["Heuristic", "Optimal Path"],
  },
  {
    label: "Rat in a Maze",
    category: "Pathfinding",
    subpage: "RatInMaze",
    keywords: [
      "pathfinding",
      "maze",
      "rat",
      "backtracking",
      "bfs",
      "dfs",
      "graph traversal",
    ],
    number: "N/A",
    icon: MapPin,
    description:
      "Find a path for a rat to reach from a source to a destination in a maze.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Backtracking / BFS / DFS",
    timeComplexity: "O(N*M)",
    tags: ["Backtracking", "Matrix"],
  },
  {
    label: "Flood Fill",
    category: "Pathfinding",
    subpage: "FloodFill",
    keywords: [
      "pathfinding",
      "flood fill",
      "bucket tool",
      "bfs",
      "dfs",
      "graph traversal",
      "matrix",
      "733",
    ],
    number: "733",
    icon: Zap,
    description:
      "Fill an area with a color starting from a seed point. Implemented using BFS.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-cyan-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "BFS / DFS",
    timeComplexity: "O(N*M)",
    platforms: ["LeetCode #733"],
    tags: ["Matrix", "Traversal"],
  },
  {
    label: "Color Islands",
    category: "Pathfinding",
    subpage: "ColorIslands",
    keywords: [
      "pathfinding",
      "color islands",
      "flood fill",
      "number of islands",
      "200",
    ],
    number: "200",
    icon: Grid,
    description: "Identify and color each island (connected 1s) in a 2D grid.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Flood Fill (BFS / DFS)",
    timeComplexity: "O(N*M)",
    platforms: ["LeetCode #200"],
    tags: ["Matrix", "Traversal", "Islands"],
  },

  // =================================================================
  // RECURSION
  // =================================================================
  {
    label: "Subset Sum",
    category: "Recursion",
    subpage: "SubsetSumVisualizer",
    keywords: [
      "recursion",
      "subset",
      "sum",
      "backtracking",
      "dynamic programming",
    ],
    number: "25",
    icon: GitMerge,
    description: "Check if a subset of an array sums up to a given value.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Backtracking",
    timeComplexity: "O(2^n)",
    tags: ["Backtracking", "DP"],
  },
  {
    label: "Tower of Hanoi",
    category: "Recursion",
    subpage: "TowerOfHanoiVisualizer",
    keywords: ["recursion", "tower", "hanoi", "puzzle", "divide and conquer"],
    number: "26",
    icon: Container,
    description:
      "Move a stack of disks from one rod to another following specific rules.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(2^n)",
    tags: ["Classic Puzzle", "Divide & Conquer"],
  },
  {
    label: "Fibonacci",
    category: "Recursion",
    subpage: "FibonacciVisualizer",
    keywords: ["recursion", "fibonacci", "memoization", "dynamic programming"],
    number: "27",
    icon: Zap,
    description:
      "Visualize the recursive call tree for the Fibonacci sequence.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Tree Recursion",
    timeComplexity: "O(2^n)",
    tags: ["Fundamental", "Tree Recursion"],
  },
  {
    label: "Factorial",
    category: "Recursion",
    subpage: "FactorialVisualizer",
    keywords: ["recursion", "factorial", "linear recursion", "call stack"],
    number: "28",
    icon: Hash,
    description:
      "Calculate factorial using recursion and visualize the linear call stack.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Linear Recursion",
    timeComplexity: "O(n)",
    tags: ["Fundamental", "Call Stack"],
  },
  {
    label: "N-Queens",
    category: "Recursion",
    subpage: "NQueensVisualizer",
    keywords: ["recursion", "n-queens", "backtracking", "chessboard", "puzzle"],
    number: "29",
    icon: Crown,
    description:
      "Place N queens on an N×N chessboard so that no two queens attack each other.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-pink-500 to-rose-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Backtracking",
    timeComplexity: "O(n!)",
    tags: ["Backtracking", "Classic Puzzle"],
  },
  {
    label: "Binary Search (Recursive)",
    category: "Recursion",
    subpage: "BinarySearchRecursiveVisualizer",
    keywords: [
      "recursion",
      "binary search",
      "divide and conquer",
      "sorted array",
    ],
    number: "30",
    icon: Search,
    description: "Search a sorted array using recursive binary search.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-teal-500 to-emerald-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(log n)",
    tags: ["Divide & Conquer", "Logarithmic"],
  },

  // =================================================================
  // STRINGS
  // =================================================================
  {
    label: "Check Palindrome",
    category: "Strings",
    subpage: "PalindromeCheck",
    keywords: ["string", "palindrome", "two pointers", "reverse", "basic"],
    number: "1",
    icon: ArrowLeftRight,
    description: "Check if a string reads the same backward as forward.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Two Pointers"],
  },
  {
    label: "Reverse String",
    category: "Strings",
    subpage: "ReverseString",
    keywords: ["string", "reverse", "in-place", "two pointers", "344"],
    number: "344",
    icon: RefreshCw,
    description: "Reverse the characters in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #344"],
    tags: ["Beginner", "In-place"],
  },
  {
    label: "Count Vowels",
    category: "Strings",
    subpage: "CountVowels",
    keywords: ["string", "count", "vowels", "basic", "traversal"],
    number: "3",
    icon: Hash,
    description: "Count the number of vowels in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["GfG"],
    tags: ["Beginner", "Counting"],
  },
  {
    label: "First Unique Character",
    category: "Strings",
    subpage: "FirstUniqueChar",
    keywords: ["string", "first", "unique", "character", "hash map", "387"],
    number: "387",
    icon: CheckCircle2,
    description: "Find the first non-repeating character in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #387"],
    tags: ["Beginner", "Hash Map"],
  },
  {
    label: "Valid Anagram", // Also in Hashing
    category: "Strings",
    subpage: "ValidAnagram",
    keywords: ["string", "anagram", "hashing", "frequency", "242"],
    number: "242",
    icon: Repeat,
    description: "Check if two strings are anagrams of each other.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #242", "GfG"],
    tags: ["Hashing", "Frequency"],
  },
  {
    label: "Longest Common Prefix",
    category: "Strings",
    subpage: "LongestCommonPrefix",
    keywords: ["string", "longest", "common", "prefix", "14"],
    number: "14",
    icon: AlignLeft,
    description: "Find the longest common prefix among an array of strings.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-violet-500 to-purple-500",
    iconColor: "text-violet-400",
    iconBg: "bg-violet-500/20",
    borderColor: "border-violet-500/30",
    technique: "String Matching",
    timeComplexity: "O(n*m)",
    platforms: ["LeetCode #14", "GfG"],
    tags: ["Prefix", "Comparison"],
  },
  {
    label: "String Compression",
    category: "Strings",
    subpage: "StringCompression",
    keywords: ["string", "compression", "two pointers", "in-place", "443"],
    number: "443",
    icon: Scissors,
    description: "Compress string using character counts.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-pink-500 to-rose-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #443"],
    tags: ["Compression", "In-place"],
  },
  {
    label: "Reverse Words",
    category: "Strings",
    subpage: "ReverseWords",
    keywords: ["string", "reverse", "words", "parsing", "151"],
    number: "151",
    icon: Text,
    description: "Reverse the order of words in a string.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "String Manipulation",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #151", "GfG"],
    tags: ["Words", "Parsing"],
  },
  {
    label: "Longest Palindromic Substring",
    category: "Strings",
    subpage: "LongestPalindrome",
    keywords: [
      "string",
      "longest",
      "palindromic",
      "substring",
      "expand around center",
      "5",
    ],
    number: "5",
    icon: ArrowLeftRight,
    description: "Find the longest palindromic substring in a string.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-fuchsia-500 to-purple-500",
    iconColor: "text-fuchsia-400",
    iconBg: "bg-fuchsia-500/20",
    borderColor: "border-fuchsia-500/30",
    technique: "Expand Around Center",
    timeComplexity: "O(n²)",
    platforms: ["LeetCode #5", "GfG"],
    tags: ["Palindrome", "DP"],
  },
  {
    label: "Group Anagrams",
    category: "Strings",
    subpage: "GroupAnagrams",
    keywords: ["string", "group", "anagrams", "hashing", "49"],
    number: "49",
    icon: Repeat,
    description: "Group strings that are anagrams of each other.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Hashing",
    timeComplexity: "O(n*k)",
    platforms: ["LeetCode #49", "GfG"],
    tags: ["Grouping", "Hash Map"],
  },
  {
    label: "Is Subsequence",
    category: "Strings",
    subpage: "IsSubSequence", // <-- Combinando com seu arquivo
    keywords: ["string", "subsequence", "two pointers", "leetcode", "392"],
    number: "392",
    icon: Check, // <-- Vamos usar o ícone "Check"
    description: "Check if one string is a subsequence of another.",
    difficulty: "Easy", // <-- LeetCode diz que é Easy
    tier: "Tier 2", // <-- "Easy" parece ser Tier 2 nesse projeto
    difficultyColor: "text-blue-400", // Padrão "Easy"
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-sky-500 to-cyan-500", // Um novo gradiente
    iconColor: "text-sky-400",
    iconBg: "bg-sky-500/20",
    borderColor: "border-sky-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)", // Onde n é o tamanho da string 't'
    platforms: ["LeetCode #392"],
    tags: ["Two Pointers", "Beginner"],
  },

  // =================================================================
  // HASHING
  // =================================================================
  {
    label: "Valid Anagram", // Also in Strings
    category: "Hashing",
    subpage: "ValidAnagram",
    keywords: [
      "hashing",
      "anagram",
      "valid",
      "character counting",
      "242",
      "string",
    ],
    number: "242",
    icon: Search,
    description: "Check if two strings are anagrams using character counting.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-pink-500 to-purple-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Hash Map",
    timeComplexity: "O(n)",
    tags: ["Frequency", "Strings"],
  },
  {
    label: "Subarray Sum Equals K",
    category: "Hashing",
    subpage: "SubarraySumEqualsK",
    keywords: ["hashing", "subarray", "sum", "equals k", "prefix sum", "560"],
    number: "560",
    icon: Database,
    description:
      "Count subarrays whose elements sum to k using prefix sums and hashing.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Prefix Sum + Hash Map",
    timeComplexity: "O(n)",
    tags: ["Prefix Sum", "Arrays"],
  },
  {
    label: "Longest Consecutive Sequence",
    category: "Hashing",
    subpage: "LongestConsecutiveSequence",
    keywords: [
      "hashing",
      "longest",
      "consecutive",
      "sequence",
      "hash set",
      "128",
    ],
    number: "128",
    icon: Hash,
    description:
      "Find the longest sequence of consecutive numbers using a set.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Hash Set Search",
    timeComplexity: "O(n)",
    tags: ["Set", "Arrays"],
  },
  {
  label: "Equal Rows and Columns",
  category: "Hashing",
  subpage: "EqualRowsColumnPairs",
  keywords: [
    "hashing",
    "equal",
    "rows",
    "columns",
    "pairs",
    "grid",
    "matrix",
    "2352",
  ],
  number: "2352",
  icon: Grid3x3,
  description:
    "Count pairs where a row and column contain identical sequences.",
  difficulty: "Medium",
  tier: "Tier 3",
  difficultyColor: "text-yellow-400",
  difficultyBg: "bg-yellow-400/10",
  difficultyBorder: "border-yellow-400/30",
  gradient: "from-purple-500 to-pink-500",
  iconColor: "text-purple-400",
  iconBg: "bg-purple-500/20",
  borderColor: "border-purple-500/30",
  technique: "Hash Map Frequency",
  timeComplexity: "O(n³)",
  tags: ["Hash Map", "Matrix", "Arrays"],
},

  // =================================================================
  // GREEDY ALGORITHMS
  // =================================================================
  {
    label: "Best Time to Buy and Sell Stock II",
    category: "GreedyAlgorithms",
    subpage: "BestTimeStockII",
    keywords: ["greedy", "stocks", "buy", "sell", "profit", "122"],
    number: "122",
    icon: TrendingUp,
    description:
      "Maximize profit by buying and selling stocks multiple times with a greedy approach.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Greedy Profit",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #122"],
    tags: ["Stocks", "Profit Maximization"],
  },
  {
    label: "Two City Scheduling",
    category: "GreedyAlgorithms",
    subpage: "TwoCityScheduling",
    keywords: [
      "greedy",
      "two city",
      "scheduling",
      "cost",
      "optimization",
      "1029",
    ],
    number: "1029",
    icon: Users,
    description:
      "Schedule interviews for two cities, minimizing the total cost using greedy selection.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Cost Difference",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #1029"],
    tags: ["Scheduling", "Optimization"],
  },
  {
    label: "Jump Game II",
    category: "GreedyAlgorithms",
    subpage: "JumpGameII",
    keywords: ["greedy", "jump game", "bfs", "array", "45"],
    number: "45",
    icon: Target,
    description:
      "Find the minimum number of jumps to reach the end of an array using a greedy BFS approach.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Greedy BFS",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #45"],
    tags: ["Array Jumping", "BFS"],
  },
  {
    label: "Gas Station",
    category: "GreedyAlgorithms",
    subpage: "GasStation",
    keywords: ["greedy", "gas station", "circular", "route", "circuit", "134"],
    number: "134",
    icon: Circle,
    description:
      "Find the starting gas station to complete a circular route using a greedy check.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Circuit Check",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #134"],
    tags: ["Circular Route", "Optimization"],
  },
  {
    label: "Job Scheduling",
    category: "GreedyAlgorithms",
    subpage: "JobScheduling",
    keywords: ["greedy", "dp", "scheduling", "profit", "1235"],
    number: "1235",
    icon: Clock, // Using Clock icon
    description:
      "Maximize profit by scheduling jobs with deadlines and profits.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-orange-600",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Greedy + DP / Binary Search",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #1235"],
    tags: ["Scheduling", "DP", "Hard"],
  },

  // =================================================================
  // DYNAMIC PROGRAMMING
  // =================================================================
  {
    label: "0/1 Knapsack",
    category: "Dynamic Programming",
    subpage: "KnapSack",
    keywords: [
      "dp",
      "dynamic programming",
      "knapsack",
      "0/1",
      "partition",
      "subset sum",
      "416",
    ],
    number: "416",
    icon: TrendingUp,
    description:
      "Determine the maximum value that can be put in a knapsack of capacity W.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-400 to-orange-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Dynamic Programming",
    timeComplexity: "O(N × W)",
    tags: ["Classic DP", "Optimization"],
  },
  {
    label: "Longest Common Subsequence",
    category: "Dynamic Programming",
    subpage: "LongestCommonSubsequence",
    keywords: ["dp", "lcs", "string", "subsequence", "1143"],
    number: "1143",
    icon: Repeat,
    description:
      "Find the length of the longest subsequence common to two strings.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-indigo-500 to-blue-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Dynamic Programming (2D Table)",
    timeComplexity: "O(m × n)",
    platforms: ["LeetCode #1143", "GfG"],
    tags: ["DP", "String", "Subsequence"],
  },
  {
    label: "Coin Change",
    category: "Dynamic Programming",
    subpage: "CoinChange",
    keywords: ["dp", "coin change", "minimum coins", "322"],
    number: "322",
    icon: Coins,
    description:
      "Find the minimum number of coins needed to make a given amount.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-500 to-amber-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Dynamic Programming (Bottom-Up)",
    timeComplexity: "O(amount × n)",
    platforms: ["LeetCode #322", "GfG"],
    tags: ["DP", "Coin Change", "Optimization"],
  },
  {
    label: "Edit Distance",
    category: "Dynamic Programming",
    subpage: "EditDistance",
    keywords: ["dp", "edit distance", "string", "72"],
    number: "72",
    icon: Edit,
    description:
      "Find the minimum number of operations to convert one string into another.",
    difficulty: "Hard",
    tier: "Tier 4",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-rose-500 to-red-500",
    iconColor: "text-red-400",
    iconBg: "bg-rose-500/20",
    borderColor: "border-rose-500/30",
    technique: "Dynamic Programming (2D Table)",
    timeComplexity: "O(m × n)",
    platforms: ["LeetCode #72", "GfG"],
    tags: ["DP", "String", "Edit Distance"],
  },
  {
    label: "Longest Increasing Subsequence",
    category: "Dynamic Programming",
    subpage: "LISubsequence",
    keywords: ["dp", "lis", "array", "300"],
    number: "300",
    icon: TrendingUp,
    description:
      "Find the length of the longest increasing subsequence in an array.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-sky-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Dynamic Programming (Binary Search Optimization)",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #300", "GfG"],
    tags: ["DP", "Subsequence", "Binary Search"],
  },
  {
    label: "Burst Balloons",
    category: "Dynamic Programming",
    subpage: "BurstBalloons", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "burst",
      "balloons",
      "312",
      "interval dp",
      "matrix chain multiplication",
    ],
    number: "312",
    icon: Zap, // Using Zap for the "burst" theme
    description:
      "Find the maximum coins you can collect by bursting balloons in an optimal order using interval DP.",
    difficulty: "Hard",
    tier: "Tier 1", // Tiers are subjective, adjust as needed
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-orange-600", // Fiery gradient for "burst"
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Interval DP",
    timeComplexity: "O(n³)",
    tags: ["Interval DP", "Optimization"],
  },
  {
    label: "Buy/Sell Stock IV",
    category: "Dynamic Programming",
    subpage: "SellStockIV", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "stock",
      "buy",
      "sell",
      "transaction",
      "k",
      "188",
    ],
    number: "188",
    icon: LineChart, // Icon for stock charts
    description:
      "Find the maximum profit from at most 'k' transactions using space-optimized DP.",
    difficulty: "Hard",
    tier: "Tier 2",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-green-600 to-blue-700", // Green/Blue for stocks
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Dynamic Programming",
    timeComplexity: "O(N × K)",
    tags: ["Classic DP", "Optimization", "Space-Optimized"],
  },
  {
    label: "Unique Paths",
    category: "Dynamic Programming",
    subpage: "UniquePaths", // MUST match your navigate() case
    keywords: [
      "dp",
      "dynamic programming",
      "grid",
      "paths",
      "robot",
      "unique",
      "62",
    ],
    number: "62",
    icon: Grid3x3,
    description:
      "Count the number of unique paths in an m×n grid from the top-left corner to the bottom-right using dynamic programming.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-600 to-blue-700",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Tabulation",
    timeComplexity: "O(m×n)",
    platforms: ["LeetCode #62"],
    tags: ["Grid DP", "Combinatorics", "Classic Problem"],
  },
  // Graphs
  {
    label: "Max Flow (Edmonds–Karp, Dinic)",
    category: "Graphs",
    subpage: "NetworkFlow",
    keywords: [
      "graphs",
      "graph",
      "max flow",
      "network flow",
      "flow",
      "edmonds-karp",
      "edmonds karp",
      "dinic",
      "ford-fulkerson",
      "residual",
      "bottleneck",
    ],
    number: "N/A",
    icon: GitMerge,
    description:
      "Visualize max flow with Edmonds–Karp (BFS) and Dinic (level graph): residual capacities, augmenting paths, bottlenecks.",
    difficulty: "Hard",
    tier: "Tier 2",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-blue-600 to-indigo-700",
    iconColor: "text-blue-300",
    iconBg: "bg-blue-600/20",
    borderColor: "border-blue-600/30",
    technique: "Edmonds–Karp, Dinic",
    timeComplexity: "EK: O(V·E²), Dinic: O(V²·E)",
    tags: ["Residual Graph", "Augmenting Path", "Blocking Flow"],
  },
];
