/**
 * Centralized catalog for problems across the site.
 * This file is the single source of truth for all algorithm and problem data.
 */

// --- ✅ Combined Icon Imports for ALL Categories ---
import {
  Container,
  Droplets,
  ToggleRight,
  LineChart,
  ArrowUpDown,
  TrendingUp,
  Target,
  Calculator,
  Merge,
  Maximize2,
  Minus,
  Plus,
  MoveRight,
  BarChart3,
  RotateCcw,
  ArrowDownUp,
  GitMerge,
  Shuffle,
  Code2,
  Layers,
  Trees,
  ArrowRightLeft,
  ShoppingBasket,
  Grid,
  GaugeCircle,
  Mountain,
  Clock,
  Search,
  SearchCode,
  Share2,
  GitBranch,
  Route,
  Network,
  ArrowLeftRight,
  RefreshCw,
  Hash,
  CheckCircle2,
  Repeat,
  AlignLeft,
  Scissors,
  Text,
  Settings,
  Database,
  Infinity as InfinityIcon,
  Zap,
  Crown,
  Users,
  Circle,
  FlipHorizontal,
  Binary,
  BarChart4,
  List,
  Filter,
  MapPin,
  CheckCircle,
  Edit,
  Coins,
  ListOrdered,
} from "lucide-react";

export const problems = [
  // =================================================================
  // ARRAYS
  // =================================================================
  {
    label: "Container With Most Water",
    category: "Arrays",
    subpage: "ContainerWithMostWater",
    keywords: ["array", "two pointers", "container", "water", "11"],
    number: "11",
    icon: Container,
    description: "Find two lines that form a container with the most water.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #11", "GfG"],
    tags: ["Two Pointers", "Area"],
  },
  {
    label: "3Sum",
    category: "Arrays",
    subpage: "ThreeSum",
    keywords: ["array", "two pointers", "three sum", "3sum", "triplet", "15"],
    number: "15",
    icon: Target,
    description: "Find all unique triplets that sum up to zero.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-emerald-500 to-green-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n²)",
    platforms: ["LeetCode #15", "GfG"],
    tags: ["Two Pointers", "Sorting", "Triplets"],
  },
  {
    label: "4Sum",
    category: "Arrays",
    subpage: "4Sum",
    keywords: [
      "array",
      "four sum",
      "4sum",
      "quadruplets",
      "two pointers",
      "18",
    ],
    number: "18",
    icon: Layers,
    description:
      "Find all unique quadruplets in the array which give the sum of a target.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n³)",
    platforms: ["LeetCode #18", "GfG"],
    tags: ["Two Pointers", "Sorting", "Quadruplets"],
  },
  {
    label: "Trapping Rain Water",
    category: "Arrays",
    subpage: "TrappingRainWater",
    keywords: ["array", "two pointers", "rain", "water", "42"],
    number: "42",
    icon: Droplets,
    description: "Compute how much water can be trapped after raining.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-rose-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #42", "GfG"],
    tags: ["Two Pointers", "DP", "Water"],
  },
  {
    label: "Maximum Subarray",
    category: "Arrays",
    subpage: "MaximumSubarray",
    keywords: [
      "array",
      "kadane",
      "maximum subarray",
      "53",
      "subarray sum",
      "dynamic programming",
    ],
    number: "53",
    icon: TrendingUp,
    description: "Find the subarray with the largest sum.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Kadane's Algorithm",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #53", "GfG"],
    tags: ["DP", "Kadane", "Classic"],
  },
  {
    label: "Merge Intervals",
    category: "Arrays",
    subpage: "MergeIntervals",
    keywords: ["array", "intervals", "merge", "56", "overlapping", "sorting"],
    number: "56",
    icon: Merge,
    description: "Merge all overlapping intervals.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-red-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Sorting + Greedy",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #56", "GfG"],
    tags: ["Intervals", "Sorting", "Important"],
  },
  {
    label: "Best Time to Buy and Sell Stock",
    category: "Arrays",
    subpage: "BestTimeToBuyAndSellStock",
    keywords: ["array", "stock", "profit", "buy", "sell", "121"],
    number: "121",
    icon: TrendingUp,
    description: "Find the maximum profit from a single buy and sell.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-green-500 to-emerald-600",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "One Pass",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #121"],
    tags: ["Kadane's variant", "Profit"],
  },
  {
    label: "Maximum Gap",
    category: "Arrays",
    subpage: "MaximumGap",
    keywords: ["array", "maximum", "gap", "sorting", "bucket sort", "164"],
    number: "164",
    icon: MoveRight,
    description: "Find the max gap between successive elements in sorted form.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Sorting, Traversal",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #164"],
    tags: ["Sorting", "Traversal"],
  },
  {
    label: "Rotate Array",
    category: "Arrays",
    subpage: "RotateArray",
    keywords: ["array", "rotate", "reverse", "in-place", "189"],
    number: "189",
    icon: RotateCcw,
    description: "Rotate the array to the right by k steps.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Reverse Algorithm",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #189", "GfG"],
    tags: ["Array", "In-place", "Rotation"],
  },
  {
    label: "Product of Array Except Self",
    category: "Arrays",
    subpage: "ProductOfArrayExceptSelf",
    keywords: [
      "array",
      "product",
      "prefix",
      "suffix",
      "238",
      "except self",
      "division",
    ],
    number: "238",
    icon: Calculator,
    description: "Find the product of all elements except self.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-indigo-500 to-purple-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Prefix & Suffix Products",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #238", "GfG"],
    tags: ["Array", "Prefix Sum", "Important"],
  },
  {
    label: "Move Zeros",
    category: "Arrays",
    subpage: "MoveZeros",
    keywords: ["array", "move", "zeros", "two pointers", "in-place", "283"],
    number: "283",
    icon: MoveRight,
    description: "Move all zeros to the end while maintaining order.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-violet-500 to-purple-500",
    iconColor: "text-violet-400",
    iconBg: "bg-violet-500/20",
    borderColor: "border-violet-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #283", "GfG"],
    tags: ["Two Pointers", "Partitioning"],
  },
  {
    label: "Split Array Largest Sum",
    category: "Arrays",
    subpage: "SplitArrayLargestSum",
    keywords: [
      "array",
      "split",
      "largest sum",
      "binary search",
      "greedy",
      "410",
    ],
    number: "410",
    icon: BarChart3,
    description: "Split array so the largest subarray sum is minimized.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-pink-500 to-rose-600",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Binary Search + Greedy",
    timeComplexity: "O(n log(sum))",
    platforms: ["LeetCode #410"],
    tags: ["Binary Search", "Greedy"],
  },
  {
    label: "Squares of a Sorted Array",
    category: "Arrays",
    subpage: "SquaresOfSortedArray",
    keywords: ["array", "squares", "sorted", "two pointers", "977"],
    number: "977",
    icon: ArrowUpDown,
    description: "Square each number and return the sorted array.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #977"],
    tags: ["Two Pointers", "Sorting"],
  },
  {
    label: "Max Consecutive Ones III",
    category: "Arrays",
    subpage: "MaxConsecutiveOnesIII",
    keywords: ["array", "sliding window", "ones", "1004"],
    number: "1004",
    icon: ToggleRight,
    description: "Longest subarray of 1s after flipping at most K zeros.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #1004", "GfG"],
    tags: ["Sliding Window", "Ones"],
  },
  {
    label: "Sum of Subarray Ranges",
    category: "Arrays",
    subpage: "SubarrayRanges",
    keywords: ["array", "ranges", "subarray", "stack", "monotonic", "2104"],
    number: "2104",
    icon: ArrowUpDown,
    description: "Sum of differences between max and min in all subarrays.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Array / Monotonic Stack",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #2104", "GfG"],
    tags: ["Subarrays", "Stack"],
  },
  {
    label: "Find Maximum Element",
    category: "Arrays",
    subpage: "FindMaxElement",
    keywords: ["array", "max", "find", "largest", "basic"],
    number: "1",
    icon: Maximize2,
    description: "Find the largest element in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Traversal"],
  },
  {
    label: "Find Minimum Element",
    category: "Arrays",
    subpage: "FindMinElement",
    keywords: ["array", "min", "find", "smallest", "basic"],
    number: "2",
    icon: Minus,
    description: "Find the smallest element in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-emerald-500 to-teal-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Traversal"],
  },
  {
    label: "Array Sum",
    category: "Arrays",
    subpage: "ArraySum",
    keywords: ["array", "sum", "total", "basic"],
    number: "3",
    icon: Plus,
    description: "Calculate the sum of all elements in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Sum"],
  },
  {
    label: "Reverse Array",
    category: "Arrays",
    subpage: "ReverseArray",
    keywords: ["array", "reverse", "two pointers", "in-place", "basic"],
    number: "4",
    icon: RefreshCw,
    description: "Reverse the elements of an array in place.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Two Pointers"],
  },
  {
    label: "Two Sum",
    category: "Arrays",
    subpage: "TwoSum",
    keywords: ["array", "two sum", "target", "hashmap", "1"],
    number: "1",
    icon: Target,
    description: "Find two numbers that add up to the target value.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #1", "GfG"],
    tags: ["Hashing", "Pairs"],
  },
  {
    label: "Count Zeros in Array",
    category: "Arrays",
    subpage: "CountZeros",
    keywords: ["array", "count", "zeros", "basic"],
    number: "3",
    icon: Hash,
    description: "Count the number of zero elements in an array.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["GfG"],
    tags: ["Beginner", "Counting"],
  },

  // =================================================================
  // SLIDING WINDOWS
  // =================================================================
  {
    label: "Sliding Window Maximum",
    category: "SlidingWindows",
    subpage: "SlidingWindowMaximum",
    keywords: ["sliding window", "maximum", "deque", "monotonic", "239"],
    number: "239",
    icon: BarChart3,
    description: "Find the maximum value in each sliding window of size k.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Deque / Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Deque", "Hard"],
  },
  {
    label: "Max Consecutive Ones III", // Duplicate but kept for category context
    category: "SlidingWindows",
    subpage: "MaxConsecutiveOnesIII",
    keywords: [
      "sliding window",
      "max",
      "consecutive",
      "ones",
      "flip",
      "1004",
      "array",
    ],
    number: "1004",
    icon: ToggleRight,
    description:
      "Find the longest subarray of 1s after flipping at most K zeros.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Two Pointers", "Variable Window"],
  },
  {
    label: "Fruit Into Baskets",
    category: "SlidingWindows",
    subpage: "FruitIntoBaskets",
    keywords: ["sliding window", "fruit", "baskets", "distinct", "904"],
    number: "904",
    icon: ShoppingBasket,
    description:
      "Find the length of the longest subarray with at most two distinct fruit types.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    tags: ["Variable Window", "Hash Map"],
  },
  {
    label: "Minimum Window Substring",
    category: "SlidingWindows",
    subpage: "MinimumWindow",
    keywords: [
      "sliding window",
      "minimum",
      "window",
      "substring",
      "string",
      "hash map",
      "76",
    ],
    number: "76",
    icon: Target,
    description:
      "Find the minimum window in string s that contains all characters of string t.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n+m)",
    platforms: ["LeetCode #76", "GfG"],
    tags: ["String", "Hash Map", "Minimum Window", "Advanced"],
  },
  {
    label: "Longest Substring Without Repeating Characters",
    category: "SlidingWindows",
    subpage: "LongestSubstring",
    keywords: [
      "sliding window",
      "longest",
      "substring",
      "repeating",
      "unique",
      "string",
      "hash map",
      "3",
    ],
    number: "3",
    icon: Hash,
    description:
      "Find the length of the longest substring without repeating characters.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Sliding Window",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #3", "GfG"],
    tags: ["String", "Hash Map", "Unique Characters"],
  },

  // =================================================================
  // BINARY SEARCH (New Category Added and Sorted by Number)
  // =================================================================
  {
    label: "Basic Binary Search",
    category: "BinarySearch",
    subpage: "BinarySearchBasic",
    keywords: ["binary search", "basic", "search", "sorted"],
    number: "N/A",
    icon: SearchCode,
    description:
      "The fundamental logarithmic search algorithm on a sorted array.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(log n)",
    platforms: ["All Platforms"],
    tags: ["Fundamental", "Logarithmic"],
  },
  {
    label: "Search a 2D Matrix",
    category: "BinarySearch",
    subpage: "Search2DMatrix",
    keywords: ["binary search", "matrix", "2d", "74"],
    number: "74",
    icon: SearchCode,
    description:
      "Search for a value in an m x n matrix where rows and columns are sorted.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-fuchsia-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Binary Search on 2D Array",
    timeComplexity: "O(log(m*n))",
    platforms: ["LeetCode #74"],
    tags: ["Matrix", "Logarithmic"],
  },
  {
    label: "Find First and Last Position of Element in Sorted Array",
    category: "BinarySearch",
    subpage: "FindFirstAndLastPosition",
    keywords: ["binary search", "first", "last", "position", "34"],
    number: "34",
    icon: SearchCode,
    description:
      "Find the starting and ending position of a given target value.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Modified Binary Search",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #34"],
    tags: ["Boundary Search", "Logarithmic"],
  },
  {
    label: "Search in Rotated Sorted Array",
    category: "BinarySearch",
    subpage: "SearchInRotatedSortedArray",
    keywords: ["binary search", "rotated", "sorted array", "33"],
    number: "33",
    icon: SearchCode,
    description: "Search for a target value in a rotated sorted array.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-red-500 to-rose-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Binary Search (Pivot)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #33"],
    tags: ["Pivot", "Logarithmic", "Rotated Array"],
  },
  {
    label: "Find Peak Element",
    category: "BinarySearch",
    subpage: "FindPeakElement",
    keywords: ["binary search", "peak", "element", "162"],
    number: "162",
    icon: Mountain,
    description:
      "Find a peak element in an array (an element greater than its neighbors).",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Binary Search (Gradient)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #162"],
    tags: ["Gradient", "Logarithmic"],
  },
  {
    label: "Find Minimum in Rotated Sorted Array",
    category: "BinarySearch",
    subpage: "FindMinimumInRotatedSortedArray",
    keywords: ["binary search", "minimum", "rotated", "sorted array", "153"],
    number: "153",
    icon: RotateCcw,
    description: "Find the minimum element in a rotated sorted array.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-indigo-500 to-blue-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Binary Search (Pivot)",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #153"],
    tags: ["Pivot", "Logarithmic", "Rotated Array"],
  },
  {
    label: "Peak Index in a Mountain Array",
    category: "BinarySearch",
    subpage: "PeakIndexInMountainArray",
    keywords: ["binary search", "mountain", "peak", "852"],
    number: "852",
    icon: Mountain,
    description: "Find the index of the peak element in a mountain array.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Binary Search",
    timeComplexity: "O(log n)",
    platforms: ["LeetCode #852"],
    tags: ["Mountain Array", "Logarithmic"],
  },
  {
    label: "Min Speed to Arrive on Time",
    category: "BinarySearch",
    subpage: "MinSpeedToArriveOnTime",
    keywords: ["binary search", "speed", "time", "optimization", "1870"],
    number: "1870",
    icon: Clock,
    description: "Find the minimum speed to arrive at the destination on time.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Binary Search on Answer",
    timeComplexity: "O(n log(max_speed))",
    platforms: ["LeetCode #1870"],
    tags: ["Search on Answer", "Optimization"],
  },
  {
    label: "Median of Two Sorted Arrays",
    category: "BinarySearch",
    subpage: "MedianOfTwoSortedArrays",
    keywords: ["binary search", "median", "sorted array", "hard", "4"],
    number: "4",
    icon: Share2,
    description: "Find the median of two sorted arrays of different sizes.",
    difficulty: "Hard",
    tier: "Tier 4",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-fuchsia-500 to-purple-500",
    iconColor: "text-fuchsia-400",
    iconBg: "bg-fuchsia-500/20",
    borderColor: "border-fuchsia-500/30",
    technique: "Binary Search on Partition",
    timeComplexity: "O(log(min(m,n)))",
    platforms: ["LeetCode #4"],
    tags: ["Partition", "Hard", "Classic"],
  },

  // =================================================================
  // LINKED LIST
  // =================================================================
  {
    label: "Linked List Cycle",
    category: "LinkedList",
    subpage: "LinkedListCycle",
    keywords: [
      "linked list",
      "cycle",
      "loop",
      "floyd",
      "tortoise",
      "hare",
      "141",
    ],
    number: "141",
    icon: InfinityIcon,
    description: "Determine if a given linked list contains a cycle or a loop.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-emerald-500 to-teal-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Floyd's Cycle",
    timeComplexity: "O(n)",
    tags: ["Two Pointers", "Classic"],
  },
  {
    label: "Reverse Linked List",
    category: "LinkedList",
    subpage: "ReverseLinkedList",
    keywords: ["linked list", "reverse", "iterative", "recursive", "206"],
    number: "206",
    icon: RefreshCw,
    description: "Reverse a singly linked list and return the reversed list.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-lime-500",
    iconColor: "text-lime-400",
    iconBg: "bg-lime-500/20",
    borderColor: "border-lime-500/30",
    technique: "Iterative & Recursive Reversal",
    timeComplexity: "O(n)",
    tags: ["Pointers", "Fundamental"],
  },
  {
    label: "Merge Two Sorted Lists",
    category: "LinkedList",
    subpage: "MergeTwoSortedLists",
    keywords: [
      "linked list",
      "merge",
      "sorted",
      "two pointers",
      "dummy node",
      "21",
    ],
    number: "21",
    icon: GitMerge,
    description:
      "Merge two sorted linked lists and return as a single sorted list.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-purple-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Two Pointers & Dummy Node",
    timeComplexity: "O(m + n)",
    tags: ["Two Pointers", "Classic"],
  },
  {
    label: "Sort List",
    category: "LinkedList",
    subpage: "SortList",
    keywords: [
      "linked list",
      "merge sort",
      "sort",
      "divide and conquer",
      "148",
    ],
    number: "148",
    icon: ListOrdered,
    description:
      "Sort a linked list in ascending order using merge sort.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-yellow-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Merge Sort (Divide & Conquer)",
    timeComplexity: "O(n log n)",
    tags: ["Merge Sort", "Linked List", "Divide and Conquer"],
  },


  // =================================================================
  // STACK
  // =================================================================
  {
    label: "Stack Operations",
    category: "Stack",
    subpage: "StackOperations",
    keywords: ["stack", "operations", "push", "pop", "peek", "LIFO", "basic"],
    number: "Basic",
    icon: Layers,
    description: "Visualize the core stack operations: Push, Pop, and Peek.",
    difficulty: "Fundamental",
    tier: "Tier 1",
    difficultyColor: "text-cyan-400",
    difficultyBg: "bg-cyan-400/10",
    difficultyBorder: "border-cyan-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "LIFO",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "LIFO"],
  },
  {
    label: "Permutation",
    category: "Stack",
    subpage: "Permutation",
    keywords: ["stack", "permutation", "iterative", "backtracking", "46"],
    number: "46",
    icon: ArrowUpDown,
    description:
      "Generate all permutations of an array iteratively using an explicit stack.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-emerald-500 to-green-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Explicit Stack",
    timeComplexity: "O(n × n!)",
    tags: ["Backtracking", "Iterative"],
  },
  {
    label: "Largest Rectangle in Histogram",
    category: "Stack",
    subpage: "LargestRectangleHistogram",
    keywords: ["stack", "largest", "rectangle", "histogram", "monotonic", "84"],
    number: "84",
    icon: BarChart4,
    description: "Given bar heights, find the area of the largest rectangle.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-rose-500",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Hard"],
  },
  {
    label: "Remove K Digits",
    category: "Stack",
    subpage: "RemoveKDigits",
    keywords: ["stack", "remove", "k digits", "smallest", "greedy", "402"],
    number: "402",
    icon: Scissors,
    description:
      "Given a number, remove K digits to create the smallest possible new number.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Greedy + Stack",
    timeComplexity: "O(n)",
    tags: ["Greedy", "Monotonic"],
  },
  {
    label: "Sum of Subarray Ranges", // Also in Arrays
    category: "Stack",
    subpage: "SubarrayRanges",
    keywords: [
      "stack",
      "subarray",
      "ranges",
      "sum",
      "monotonic",
      "2104",
      "array",
    ],
    number: "2104",
    icon: ArrowUpDown,
    description: "Calculate sum of (max - min) over all subarrays.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-violet-500 to-purple-500",
    iconColor: "text-violet-400",
    iconBg: "bg-violet-500/20",
    borderColor: "border-violet-500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Arrays"],
  },
  {
    label: "Next Greater Element",
    category: "Stack",
    subpage: "NextGreaterElement",
    keywords: [
      "stack",
      "next",
      "greater",
      "element",
      "monotonic",
      "circular",
      "496",
    ],
    number: "496",
    icon: ArrowUpDown,
    description:
      "Find the next greater element for each element in a circular array.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-fuchsia-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Monotonic Stack",
    timeComplexity: "O(n)",
    tags: ["Monotonic Stack", "Circular Array"],
  },

  // =================================================================
  // QUEUE
  // =================================================================
  {
    label: "Basic Queue (FIFO)",
    category: "Queue",
    subpage: "BasicQueue",
    keywords: [
      "queue",
      "fifo",
      "first-in-first-out",
      "enqueue",
      "dequeue",
      "linear",
    ],
    number: "N/A",
    icon: ArrowRightLeft,
    description:
      "Elements are added at the rear and removed from the front, like a waiting line.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-rose-500 to-pink-600",
    iconColor: "text-rose-400",
    iconBg: "bg-rose-500/20",
    borderColor: "border-rose-500/30",
    technique: "Linear Structure",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "FIFO"],
  },
  {
    label: "Circular Queue",
    category: "Queue",
    subpage: "CircularQueue",
    keywords: ["queue", "circular", "ring buffer", "array optimization"],
    number: "N/A",
    icon: List,
    description: "Optimized queue using a circular array to reuse space.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-pink-500 to-rose-600",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Circular Array",
    timeComplexity: "O(1)",
    tags: ["Optimization", "Array"],
  },
  {
    label: "Implement Queue using Stacks",
    category: "Queue",
    subpage: "QueueUsingStacks",
    keywords: ["queue", "implement", "stacks", "design", "amortized", "232"],
    number: "232",
    icon: Container,
    description: "Implement a FIFO queue using only two LIFO stacks.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-indigo-600",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Two Stacks",
    timeComplexity: "Amortized O(1)",
    tags: ["Design", "Stack"],
  },

  // =================================================================
  // SORTING
  // =================================================================
  {
    label: "Bubble Sort",
    category: "Sorting",
    subpage: "BubbleSort",
    keywords: ["sorting", "bubble", "swap", "basic"],
    number: "912",
    icon: ArrowDownUp,
    description:
      "A simple algorithm that repeatedly steps through the list, comparing and swapping adjacent elements.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Swapping",
    timeComplexity: "O(n²)",
    tags: ["Basic", "In-place"],
  },
  {
    label: "Merge Sort",
    category: "Sorting",
    subpage: "MergeSort",
    keywords: ["sorting", "merge", "divide and conquer", "stable"],
    number: "N/A",
    icon: GitMerge,
    description:
      "An efficient, stable algorithm using the divide and conquer paradigm.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-500 to-amber-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "Stable"],
  },
  {
    label: "Quick Sort",
    category: "Sorting",
    subpage: "QuickSort",
    keywords: ["sorting", "quick", "partition", "pivot"],
    number: "N/A",
    icon: Shuffle,
    description:
      "An efficient algorithm that uses partitioning to divide the array into smaller sub-arrays.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-red-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Partitioning",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "In-place"],
  },
  {
    label: "Insertion Sort",
    category: "Sorting",
    subpage: "InsertionSort",
    keywords: ["sorting", "insertion", "insert", "stable"],
    number: "N/A",
    icon: Code2,
    description:
      "A simple algorithm that builds the final sorted array one element at a time.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-lime-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Insertion",
    timeComplexity: "O(n²)",
    tags: ["Basic", "Stable"],
  },
  {
    label: "Radix Sort",
    category: "Sorting",
    subpage: "RadixSort",
    keywords: ["sorting", "radix", "digit", "non-comparative"],
    number: "N/A",
    icon: Layers,
    description:
      "A non-comparative algorithm that sorts numbers by processing individual digits.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Digit-wise Sorting",
    timeComplexity: "O(d*(n+k))",
    tags: ["Non-comparative", "Linear Time"],
  },
  {
    label: "Counting Sort",
    category: "Sorting",
    subpage: "CountingSort",
    keywords: ["sorting", "counting", "frequency", "non-comparative"],
    number: "N/A",
    icon: BarChart3,
    description:
      "A non-comparative algorithm that counts the frequency of each element to sort them.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-yellow-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Counting & Placement",
    timeComplexity: "O(n+k)",
    tags: ["Non-comparative", "Linear Time"],
  },
  {
    label: "Heap Sort",
    category: "Sorting",
    subpage: "HeapSort",
    keywords: ["sorting", "heap", "priority queue", "binary heap"],
    number: "N/A",
    icon: Trees,
    description:
      "A comparison-based technique based on a binary heap data structure.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Heap-based Sorting",
    timeComplexity: "O(n log n)",
    tags: ["Efficient", "In-place"],
  },
  {
    label: "Selection Sort",
    category: "Sorting",
    subpage: "SelectionSort",
    keywords: ["sorting", "selection", "select", "minimum"],
    number: "N/A",
    icon: Target,
    description:
      "A simple algorithm that repeatedly selects the minimum element and moves it to the sorted part.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Selection",
    timeComplexity: "O(n²)",
    tags: ["Basic", "In-place"],
  },
  {
    label: "Shell Sort",
    category: "Sorting",
    subpage: "ShellSort",
    keywords: ["sorting", "shell", "gap", "insertion sort"],
    number: "N/A",
    icon: Layers,
    description:
      "An optimized version of insertion sort that allows the exchange of items that are far apart.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Gap Insertion",
    timeComplexity: "O(n^1.5)",
    tags: ["Optimization", "In-place"],
  },
  {
    label: "Comb Sort",
    category: "Sorting",
    subpage: "CombSort",
    keywords: ["sorting", "comb", "gap", "bubble sort"],
    number: "N/A",
    icon: Filter,
    description: "An improvement over Bubble Sort, Comb Sort eliminates 'turtles' for better performance.",
    difficulty: "Medium",
    tier: "Tier 1",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Gap Insertion",
    timeComplexity: "O(n log n)",
    tags: ["Optimization", "In-place"],
  },
  // =================================================================
  // HEAPS
  // =================================================================
  {
     category: 'Heaps',
    subpage: 'Heapify', // <-- This MUST match the 'case' in HeapsPage
    label: 'Heapify (Build Heap)',
    number: 'H-01', // Custom ID for a concept
    difficulty: 'Medium',
    difficultyBg: 'bg-yellow-500/10',
    difficultyColor: 'text-yellow-400',
    difficultyBorder: 'border-yellow-500/30',
    tier: 'Tier 1',
    description: 'Learn how to convert an unordered array into a max-heap in-place using the sift-down (heapify) operation.',
    icon: Layers, // This is already imported
    gradient: 'from-teal-700 to-cyan-800',
    borderColor: 'border-teal-600',
    iconBg: 'bg-teal-700/20',
    iconColor: 'text-teal-300',
    tags: ['Heap', 'In-Place', 'Data Structure', 'Concept'],
    technique: 'Sift-Down',
    timeComplexity: 'O(n)',
    platforms: ['Concept']
  },
  {
    category: 'Heaps',
    subpage: 'TopKFrequent', // <-- This MUST match the 'case' in HeapsPage
    label: 'Top K Frequent Elements',
    number: "347",
    difficulty: 'Medium',
    difficultyBg: 'bg-yellow-500/10',
    difficultyColor: 'text-yellow-400',
    difficultyBorder: 'border-yellow-500/30',
    tier: 'Tier 2',
    description: 'Given an integer array and an integer k, return the k most frequent elements. A min-heap is a perfect solution.',
    icon: TrendingUp, // This is already imported
    gradient: 'from-purple-700 to-indigo-800',
    borderColor: 'border-purple-600',
    iconBg: 'bg-purple-700/20',
    iconColor: 'text-purple-300',
    tags: ['Heap', 'Priority Queue', 'Hash Map'],
    technique: 'Min-Heap',
    timeComplexity: 'O(n log k)',
    platforms: ['LeetCode #347']
  },

  // =================================================================
  // TREES
  // =================================================================
  {
    label: "Construct Tree from Traversal",
    category: "Trees",
    subpage: "ConstructBinaryTree",
    keywords: [
      "tree",
      "construct",
      "build",
      "preorder",
      "inorder",
      "traversal",
      "105",
    ],
    number: "105",
    icon: GitMerge,
    description:
      "Build a binary tree from its preorder and inorder traversal arrays.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-emerald-500 to-green-500",
    iconColor: "text-emerald-400",
    iconBg: "bg-emerald-500/20",
    borderColor: "border-emerald-500/30",
    technique: "Recursion & Hashing",
    timeComplexity: "O(n)",
    tags: ["Recursion", "Hash Map"],
  },
  {
    label: "LCA of Deepest Leaves",
    category: "Trees",
    subpage: "LCAofDeepestLeaves",
    keywords: [
      "tree",
      "lca",
      "lowest common ancestor",
      "deepest leaves",
      "dfs",
      "1123",
    ],
    number: "1123",
    icon: GitMerge,
    description:
      "Find the lowest common ancestor node of a binary tree's deepest leaves.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Depth-First Search (DFS)",
    timeComplexity: "O(n)",
    tags: ["DFS", "Recursion"],
  },
  {
    label: "Validate Binary Search Tree",
    category: "Trees",
    subpage: "ValidateBST",
    keywords: ["tree", "validate", "bst", "binary search tree", "dfs", "98"],
    number: "98",
    icon: CheckCircle,
    description:
      "Determine if a given binary tree is a valid Binary Search Tree (BST).",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "DFS & Boundaries",
    timeComplexity: "O(n)",
    tags: ["DFS", "Validation"],
  },
  {
    label: "AVL Tree Visualizer",
    category: "Trees",
    subpage: "AVLTree",
    keywords: [
      "tree",
      "avl",
      "balanced",
      "binary search tree",
      "rotations",
      "110",
    ],
    number: "110",
    icon: GitMerge,
    description: "Visualize AVL tree insertions and self-balancing rotations.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Balanced Binary Search Tree",
    timeComplexity: "O(log n)",
    tags: ["Self-Balancing", "BST"],
  },
  {
  label: "Symmetric Tree",
  category: "Trees",
  subpage: "SymmetricTreeVisualizer",
  keywords: [
    "tree",
    "symmetric",
    "mirror",
    "binary tree",
    "recursion",
    "iterative",
    "101"
  ],
  number: "111",
  icon: GitBranch,
  description: "Check whether a binary tree is symmetric (a mirror of itself) using recursion or iterative BFS/DFS approaches.",
  difficulty: "Easy",
  tier: "Tier 1",
  difficultyColor: "text-green-400",
  difficultyBg: "bg-green-400/10",
  difficultyBorder: "border-green-400/30",
  gradient: "from-green-400 to-emerald-500",
  iconColor: "text-green-400",
  iconBg: "bg-green-500/20",
  borderColor: "border-green-500/30",
  technique: "Tree Traversal (Recursion / BFS)",
  timeComplexity: "O(n)",
  tags: ["Recursion", "Mirror", "BFS", "DFS"]
},

  // =================================================================
  // DESIGN
  // =================================================================
  {
    label: "LRU Cache",
    category: "Design",
    subpage: "LRUCache",
    keywords: [
      "design",
      "lru",
      "cache",
      "least recently used",
      "hashmap",
      "doubly linked list",
      "146",
    ],
    number: "146",
    icon: Settings,
    description:
      "Implement an LRU (Least Recently Used) cache with O(1) get and put operations.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-teal-500 to-emerald-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "HashMap + Doubly Linked List",
    timeComplexity: "O(1)",
    tags: ["Cache", "Classic"],
  },
  {
    label: "LFU Cache",
    category: "Design",
    subpage: "LFUCache",
    keywords: [
      "design",
      "lfu",
      "cache",
      "least frequently used",
      "hashmap",
      "460",
    ],
    number: "460",
    icon: Settings,
    description:
      "Implement an LFU (Least Frequently Used) cache that evicts the least frequently used key.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-pink-500 to-rose-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "HashMap + Frequency Map",
    timeComplexity: "O(1)",
    tags: ["Cache", "Hard"],
  },
  {
    label: "Design HashMap",
    category: "Design",
    subpage: "DesignHashMap",
    keywords: ["design", "hashmap", "hashtable", "hash function", "706"],
    number: "706",
    icon: Settings,
    description:
      "Design a HashMap that supports put, get, and remove operations in O(1) time.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-lime-500",
    iconColor: "text-lime-400",
    iconBg: "bg-lime-500/20",
    borderColor: "border-lime-500/30",
    technique: "Array + Hashing",
    timeComplexity: "O(1)",
    tags: ["Fundamental", "Data Structure"],
  },
  {
    label: "Design Linked List",
    category: "Design",
    subpage: "DesignLinkedList",
    keywords: ["design", "linked list", "pointers", "707"],
    number: "707",
    icon: Settings,
    description:
      "Design a Linked List that supports insert, delete, and get operations.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-500 to-amber-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Pointers",
    timeComplexity: "O(n)",
    tags: ["Fundamental", "Data Structure"],
  },
  {
    label: "Min Stack",
    category: "Design",
    subpage: "MinStack",
    keywords: ["design", "min stack", "stack", "minimum", "155"],
    number: "155",
    icon: Layers,
    description:
      "Design a stack that supports retrieving the minimum element in constant time.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Stack + Min Tracking",
    timeComplexity: "O(1)",
    tags: ["Stack", "Optimization"],
  },
  {
    label: "Implement Trie (Prefix Tree)",
    category: "Design",
    subpage: "ImplementTrie",
    keywords: ["design", "trie", "prefix tree", "strings", "208"],
    number: "208",
    icon: Search,
    description:
      "Implement a trie with insert, search, and startsWith methods.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-teal-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Trie / Tree",
    timeComplexity: "O(m)",
    tags: ["Tree", "Strings"],
  },

  // =================================================================
  // PATHFINDING
  // =================================================================
  {
    label: "Rat in a Maze",
    category: "Pathfinding",
    subpage: "RatInMaze",
    keywords: [
      "pathfinding",
      "maze",
      "rat",
      "backtracking",
      "bfs",
      "dfs",
      "graph traversal",
    ],
    number: "N/A",
    icon: MapPin,
    description:
      "Find a path for a rat to reach from a source to a destination in a maze.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Backtracking / BFS / DFS",
    timeComplexity: "O(N*M)",
    tags: ["Backtracking", "Matrix"],
  },
  {
    label: "Flood Fill",
    category: "Pathfinding",
    subpage: "FloodFill",
    keywords: [
      "pathfinding",
      "flood fill",
      "bucket tool",
      "bfs",
      "dfs",
      "graph traversal",
      "matrix",
      "733",
    ],
    number: "733",
    icon: Zap,
    description:
      "Fill an area with a color starting from a seed point. Implemented using BFS.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-cyan-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "BFS / DFS",
    timeComplexity: "O(N*M)",
    platforms: ["LeetCode #733"],
    tags: ["Matrix", "Traversal"],
  },
  {
    label: "Color Islands",
    category: "Pathfinding",
    subpage: "ColorIslands",
    keywords: [
      "pathfinding",
      "color islands",
      "flood fill",
      "number of islands",
      "200",
    ],
    number: "200",
    icon: Grid,
    description: "Identify and color each island (connected 1s) in a 2D grid.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Flood Fill (BFS / DFS)",
    timeComplexity: "O(N*M)",
    platforms: ["LeetCode #200"],
    tags: ["Matrix", "Traversal", "Islands"],
  },

  // =================================================================
  // RECURSION
  // =================================================================
  {
    label: "Subset Sum",
    category: "Recursion",
    subpage: "SubsetSumVisualizer",
    keywords: [
      "recursion",
      "subset",
      "sum",
      "backtracking",
      "dynamic programming",
    ],
    number: "25",
    icon: GitMerge,
    description: "Check if a subset of an array sums up to a given value.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Backtracking",
    timeComplexity: "O(2^n)",
    tags: ["Backtracking", "DP"],
  },
  {
    label: "Tower of Hanoi",
    category: "Recursion",
    subpage: "TowerOfHanoiVisualizer",
    keywords: ["recursion", "tower", "hanoi", "puzzle", "divide and conquer"],
    number: "26",
    icon: Container,
    description:
      "Move a stack of disks from one rod to another following specific rules.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-pink-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(2^n)",
    tags: ["Classic Puzzle", "Divide & Conquer"],
  },
  {
    label: "Fibonacci",
    category: "Recursion",
    subpage: "FibonacciVisualizer",
    keywords: ["recursion", "fibonacci", "memoization", "dynamic programming"],
    number: "27",
    icon: Zap,
    description:
      "Visualize the recursive call tree for the Fibonacci sequence.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Tree Recursion",
    timeComplexity: "O(2^n)",
    tags: ["Fundamental", "Tree Recursion"],
  },
  {
    label: "Factorial",
    category: "Recursion",
    subpage: "FactorialVisualizer",
    keywords: ["recursion", "factorial", "linear recursion", "call stack"],
    number: "28",
    icon: Hash,
    description:
      "Calculate factorial using recursion and visualize the linear call stack.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-indigo-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Linear Recursion",
    timeComplexity: "O(n)",
    tags: ["Fundamental", "Call Stack"],
  },
  {
    label: "N-Queens",
    category: "Recursion",
    subpage: "NQueensVisualizer",
    keywords: ["recursion", "n-queens", "backtracking", "chessboard", "puzzle"],
    number: "29",
    icon: Crown,
    description:
      "Place N queens on an N×N chessboard so that no two queens attack each other.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-pink-500 to-rose-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Backtracking",
    timeComplexity: "O(n!)",
    tags: ["Backtracking", "Classic Puzzle"],
  },
  {
    label: "Binary Search (Recursive)",
    category: "Recursion",
    subpage: "BinarySearchRecursiveVisualizer",
    keywords: [
      "recursion",
      "binary search",
      "divide and conquer",
      "sorted array",
    ],
    number: "30",
    icon: Search,
    description: "Search a sorted array using recursive binary search.",
    difficulty: "Easy",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-teal-500 to-emerald-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Divide & Conquer",
    timeComplexity: "O(log n)",
    tags: ["Divide & Conquer", "Logarithmic"],
  },

  // =================================================================
  // STRINGS
  // =================================================================
  {
    label: "Check Palindrome",
    category: "Strings",
    subpage: "PalindromeCheck",
    keywords: ["string", "palindrome", "two pointers", "reverse", "basic"],
    number: "1",
    icon: ArrowLeftRight,
    description: "Check if a string reads the same backward as forward.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["All Platforms"],
    tags: ["Beginner", "Two Pointers"],
  },
  {
    label: "Reverse String",
    category: "Strings",
    subpage: "ReverseString",
    keywords: ["string", "reverse", "in-place", "two pointers", "344"],
    number: "344",
    icon: RefreshCw,
    description: "Reverse the characters in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #344"],
    tags: ["Beginner", "In-place"],
  },
  {
    label: "Count Vowels",
    category: "Strings",
    subpage: "CountVowels",
    keywords: ["string", "count", "vowels", "basic", "traversal"],
    number: "3",
    icon: Hash,
    description: "Count the number of vowels in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Traversal",
    timeComplexity: "O(n)",
    platforms: ["GfG"],
    tags: ["Beginner", "Counting"],
  },
  {
    label: "First Unique Character",
    category: "Strings",
    subpage: "FirstUniqueChar",
    keywords: ["string", "first", "unique", "character", "hash map", "387"],
    number: "387",
    icon: CheckCircle2,
    description: "Find the first non-repeating character in a string.",
    difficulty: "Basic",
    tier: "Tier 1",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #387"],
    tags: ["Beginner", "Hash Map"],
  },
  {
    label: "Valid Anagram", // Also in Hashing
    category: "Strings",
    subpage: "ValidAnagram",
    keywords: ["string", "anagram", "hashing", "frequency", "242"],
    number: "242",
    icon: Repeat,
    description: "Check if two strings are anagrams of each other.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-teal-500 to-cyan-500",
    iconColor: "text-teal-400",
    iconBg: "bg-teal-500/20",
    borderColor: "border-teal-500/30",
    technique: "Hashing",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #242", "GfG"],
    tags: ["Hashing", "Frequency"],
  },
  {
    label: "Longest Common Prefix",
    category: "Strings",
    subpage: "LongestCommonPrefix",
    keywords: ["string", "longest", "common", "prefix", "14"],
    number: "14",
    icon: AlignLeft,
    description: "Find the longest common prefix among an array of strings.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-violet-500 to-purple-500",
    iconColor: "text-violet-400",
    iconBg: "bg-violet-500/20",
    borderColor: "border-violet-500/30",
    technique: "String Matching",
    timeComplexity: "O(n*m)",
    platforms: ["LeetCode #14", "GfG"],
    tags: ["Prefix", "Comparison"],
  },
  {
    label: "String Compression",
    category: "Strings",
    subpage: "StringCompression",
    keywords: ["string", "compression", "two pointers", "in-place", "443"],
    number: "443",
    icon: Scissors,
    description: "Compress string using character counts.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-pink-500 to-rose-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #443"],
    tags: ["Compression", "In-place"],
  },
  {
    label: "Reverse Words",
    category: "Strings",
    subpage: "ReverseWords",
    keywords: ["string", "reverse", "words", "parsing", "151"],
    number: "151",
    icon: Text,
    description: "Reverse the order of words in a string.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-blue-400",
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "String Manipulation",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #151", "GfG"],
    tags: ["Words", "Parsing"],
  },
  {
    label: "Longest Palindromic Substring",
    category: "Strings",
    subpage: "LongestPalindrome",
    keywords: [
      "string",
      "longest",
      "palindromic",
      "substring",
      "expand around center",
      "5",
    ],
    number: "5",
    icon: ArrowLeftRight,
    description: "Find the longest palindromic substring in a string.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-fuchsia-500 to-purple-500",
    iconColor: "text-fuchsia-400",
    iconBg: "bg-fuchsia-500/20",
    borderColor: "border-fuchsia-500/30",
    technique: "Expand Around Center",
    timeComplexity: "O(n²)",
    platforms: ["LeetCode #5", "GfG"],
    tags: ["Palindrome", "DP"],
  },
  {
    label: "Group Anagrams",
    category: "Strings",
    subpage: "GroupAnagrams",
    keywords: ["string", "group", "anagrams", "hashing", "49"],
    number: "49",
    icon: Repeat,
    description: "Group strings that are anagrams of each other.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Hashing",
    timeComplexity: "O(n*k)",
    platforms: ["LeetCode #49", "GfG"],
    tags: ["Grouping", "Hash Map"],
  },
  {
    label: "Is Subsequence",
    category: "Strings",
    subpage: "IsSubSequence", // <-- Combinando com seu arquivo
    keywords: ["string", "subsequence", "two pointers", "leetcode", "392"],
    number: "392",
    icon: Check, // <-- Vamos usar o ícone "Check"
    description: "Check if one string is a subsequence of another.",
    difficulty: "Easy", // <-- LeetCode diz que é Easy
    tier: "Tier 2",     // <-- "Easy" parece ser Tier 2 nesse projeto
    difficultyColor: "text-blue-400", // Padrão "Easy"
    difficultyBg: "bg-blue-400/10",
    difficultyBorder: "border-blue-400/30",
    gradient: "from-sky-500 to-cyan-500", // Um novo gradiente
    iconColor: "text-sky-400",
    iconBg: "bg-sky-500/20",
    borderColor: "border-sky-500/30",
    technique: "Two Pointers",
    timeComplexity: "O(n)", // Onde n é o tamanho da string 't'
    platforms: ["LeetCode #392"],
    tags: ["Two Pointers", "Beginner"],
  },

  // =================================================================
  // HASHING
  // =================================================================
  {
    label: "Valid Anagram", // Also in Strings
    category: "Hashing",
    subpage: "ValidAnagram",
    keywords: [
      "hashing",
      "anagram",
      "valid",
      "character counting",
      "242",
      "string",
    ],
    number: "242",
    icon: Search,
    description: "Check if two strings are anagrams using character counting.",
    difficulty: "Easy",
    tier: "Tier 2",
    difficultyColor: "text-green-400",
    difficultyBg: "bg-green-400/10",
    difficultyBorder: "border-green-400/30",
    gradient: "from-pink-500 to-purple-500",
    iconColor: "text-pink-400",
    iconBg: "bg-pink-500/20",
    borderColor: "border-pink-500/30",
    technique: "Hash Map",
    timeComplexity: "O(n)",
    tags: ["Frequency", "Strings"],
  },
  {
    label: "Subarray Sum Equals K",
    category: "Hashing",
    subpage: "SubarraySumEqualsK",
    keywords: ["hashing", "subarray", "sum", "equals k", "prefix sum", "560"],
    number: "560",
    icon: Database,
    description:
      "Count subarrays whose elements sum to k using prefix sums and hashing.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-amber-500 to-orange-500",
    iconColor: "text-amber-400",
    iconBg: "bg-amber-500/20",
    borderColor: "border-amber-500/30",
    technique: "Prefix Sum + Hash Map",
    timeComplexity: "O(n)",
    tags: ["Prefix Sum", "Arrays"],
  },
  {
    label: "Longest Consecutive Sequence",
    category: "Hashing",
    subpage: "LongestConsecutiveSequence",
    keywords: [
      "hashing",
      "longest",
      "consecutive",
      "sequence",
      "hash set",
      "128",
    ],
    number: "128",
    icon: Hash,
    description:
      "Find the longest sequence of consecutive numbers using a set.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-blue-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Hash Set Search",
    timeComplexity: "O(n)",
    tags: ["Set", "Arrays"],
  },

  // =================================================================
  // GREEDY ALGORITHMS
  // =================================================================
  {
    label: "Best Time to Buy and Sell Stock II",
    category: "GreedyAlgorithms",
    subpage: "BestTimeStockII",
    keywords: ["greedy", "stocks", "buy", "sell", "profit", "122"],
    number: "122",
    icon: TrendingUp,
    description:
      "Maximize profit by buying and selling stocks multiple times with a greedy approach.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-green-500 to-emerald-500",
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Greedy Profit",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #122"],
    tags: ["Stocks", "Profit Maximization"],
  },
  {
    label: "Two City Scheduling",
    category: "GreedyAlgorithms",
    subpage: "TwoCityScheduling",
    keywords: [
      "greedy",
      "two city",
      "scheduling",
      "cost",
      "optimization",
      "1029",
    ],
    number: "1029",
    icon: Users,
    description:
      "Schedule interviews for two cities, minimizing the total cost using greedy selection.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-blue-500 to-cyan-500",
    iconColor: "text-blue-400",
    iconBg: "bg-blue-500/20",
    borderColor: "border-blue-500/30",
    technique: "Cost Difference",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #1029"],
    tags: ["Scheduling", "Optimization"],
  },
  {
    label: "Jump Game II",
    category: "GreedyAlgorithms",
    subpage: "JumpGameII",
    keywords: ["greedy", "jump game", "bfs", "array", "45"],
    number: "45",
    icon: Target,
    description:
      "Find the minimum number of jumps to reach the end of an array using a greedy BFS approach.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-orange-500 to-amber-500",
    iconColor: "text-orange-400",
    iconBg: "bg-orange-500/20",
    borderColor: "border-orange-500/30",
    technique: "Greedy BFS",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #45"],
    tags: ["Array Jumping", "BFS"],
  },
  {
    label: "Gas Station",
    category: "GreedyAlgorithms",
    subpage: "GasStation",
    keywords: ["greedy", "gas station", "circular", "route", "circuit", "134"],
    number: "134",
    icon: Circle,
    description:
      "Find the starting gas station to complete a circular route using a greedy check.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-purple-500 to-indigo-500",
    iconColor: "text-purple-400",
    iconBg: "bg-purple-500/20",
    borderColor: "border-purple-500/30",
    technique: "Circuit Check",
    timeComplexity: "O(n)",
    platforms: ["LeetCode #134"],
    tags: ["Circular Route", "Optimization"],
  },
  {
    label: "Job Scheduling",
    category: "GreedyAlgorithms",
    subpage: "JobScheduling",
    keywords: ["greedy", "dp", "scheduling", "profit", "1235"],
    number: "1235",
    icon: Clock, // Using Clock icon
    description:
      "Maximize profit by scheduling jobs with deadlines and profits.",
    difficulty: "Hard",
    tier: "Tier 3",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-orange-600",
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Greedy + DP / Binary Search",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #1235"],
    tags: ["Scheduling", "DP", "Hard"],
  },

  // =================================================================
  // DYNAMIC PROGRAMMING
  // =================================================================
  {
    label: "0/1 Knapsack",
    category: "Dynamic Programming",
    subpage: "KnapSack",
    keywords: [
      "dp",
      "dynamic programming",
      "knapsack",
      "0/1",
      "partition",
      "subset sum",
      "416",
    ],
    number: "416",
    icon: TrendingUp,
    description:
      "Determine the maximum value that can be put in a knapsack of capacity W.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-400 to-orange-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Dynamic Programming",
    timeComplexity: "O(N × W)",
    tags: ["Classic DP", "Optimization"],
  },
  {
    label: "Longest Common Subsequence",
    category: "Dynamic Programming",
    subpage: "LongestCommonSubsequence",
    keywords: ["dp", "lcs", "string", "subsequence", "1143"],
    number: "1143",
    icon: Repeat,
    description:
      "Find the length of the longest subsequence common to two strings.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-indigo-500 to-blue-500",
    iconColor: "text-indigo-400",
    iconBg: "bg-indigo-500/20",
    borderColor: "border-indigo-500/30",
    technique: "Dynamic Programming (2D Table)",
    timeComplexity: "O(m × n)",
    platforms: ["LeetCode #1143", "GfG"],
    tags: ["DP", "String", "Subsequence"],
  },
  {
    label: "Coin Change",
    category: "Dynamic Programming",
    subpage: "CoinChange",
    keywords: ["dp", "coin change", "minimum coins", "322"],
    number: "322",
    icon: Coins,
    description:
      "Find the minimum number of coins needed to make a given amount.",
    difficulty: "Medium",
    tier: "Tier 2",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-yellow-500 to-amber-500",
    iconColor: "text-yellow-400",
    iconBg: "bg-yellow-500/20",
    borderColor: "border-yellow-500/30",
    technique: "Dynamic Programming (Bottom-Up)",
    timeComplexity: "O(amount × n)",
    platforms: ["LeetCode #322", "GfG"],
    tags: ["DP", "Coin Change", "Optimization"],
  },
  {
    label: "Edit Distance",
    category: "Dynamic Programming",
    subpage: "EditDistance",
    keywords: ["dp", "edit distance", "string", "72"],
    number: "72",
    icon: Edit,
    description:
      "Find the minimum number of operations to convert one string into another.",
    difficulty: "Hard",
    tier: "Tier 4",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-rose-500 to-red-500",
    iconColor: "text-red-400",
    iconBg: "bg-rose-500/20",
    borderColor: "border-rose-500/30",
    technique: "Dynamic Programming (2D Table)",
    timeComplexity: "O(m × n)",
    platforms: ["LeetCode #72", "GfG"],
    tags: ["DP", "String", "Edit Distance"],
  },
  {
    label: "Longest Increasing Subsequence",
    category: "Dynamic Programming",
    subpage: "LISubsequence",
    keywords: ["dp", "lis", "array", "300"],
    number: "300",
    icon: TrendingUp,
    description:
      "Find the length of the longest increasing subsequence in an array.",
    difficulty: "Medium",
    tier: "Tier 3",
    difficultyColor: "text-yellow-400",
    difficultyBg: "bg-yellow-400/10",
    difficultyBorder: "border-yellow-400/30",
    gradient: "from-cyan-500 to-sky-500",
    iconColor: "text-cyan-400",
    iconBg: "bg-cyan-500/20",
    borderColor: "border-cyan-500/30",
    technique: "Dynamic Programming (Binary Search Optimization)",
    timeComplexity: "O(n log n)",
    platforms: ["LeetCode #300", "GfG"],
    tags: ["DP", "Subsequence", "Binary Search"],
  },
  {
    label: "Burst Balloons",
    category: "Dynamic Programming",
    subpage: "BurstBalloons", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "burst",
      "balloons",
      "312",
      "interval dp",
      "matrix chain multiplication",
    ],
    number: "312",
    icon: Zap, // Using Zap for the "burst" theme
    description:
      "Find the maximum coins you can collect by bursting balloons in an optimal order using interval DP.",
    difficulty: "Hard",
    tier: "Tier 1", // Tiers are subjective, adjust as needed
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-red-500 to-orange-600", // Fiery gradient for "burst"
    iconColor: "text-red-400",
    iconBg: "bg-red-500/20",
    borderColor: "border-red-500/30",
    technique: "Interval DP",
    timeComplexity: "O(n³)",
    tags: ["Interval DP", "Optimization"],
  },
  { 
    label: "Buy/Sell Stock IV",
    category: "Dynamic Programming",
    subpage: "SellStockIV", // This MUST match the case in DynamicProgramming.jsx
    keywords: [
      "dp",
      "dynamic programming",
      "stock",
      "buy",
      "sell",
      "transaction",
      "k",
      "188",
    ],
    number: "188",
    icon: LineChart, // Icon for stock charts
    description:
      "Find the maximum profit from at most 'k' transactions using space-optimized DP.",
    difficulty: "Hard",
    tier: "Tier 2",
    difficultyColor: "text-red-400",
    difficultyBg: "bg-red-400/10",
    difficultyBorder: "border-red-400/30",
    gradient: "from-green-600 to-blue-700", // Green/Blue for stocks
    iconColor: "text-green-400",
    iconBg: "bg-green-500/20",
    borderColor: "border-green-500/30",
    technique: "Dynamic Programming",
    timeComplexity: "O(N × K)",
    tags: ["Classic DP", "Optimization", "Space-Optimized"],
  },
];
